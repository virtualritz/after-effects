/* automatically generated by rust-bindgen 0.69.4 */

pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE: u32 = 34;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41;
pub const PF_ERMS_AVAILABLE: u32 = 42;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44;
pub const PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE: u32 = 45;
pub const PR_JOBSTATUS: u32 = 0;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_IPX: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_VOICEVIEW: u32 = 18;
pub const PF_FIREFOX: u32 = 19;
pub const PF_UNKNOWN1: u32 = 20;
pub const PF_BAN: u32 = 21;
pub const PF_MAX: u32 = 22;
pub const kPrMaxPath: u32 = 260;
pub const kPrMaxName: u32 = 260;
pub const kPrForceEnumToIntValue: u32 = 4294967295;
pub const kPrSDKTimeSuite: &[u8; 20] = b"Premiere Time Suite\0";
pub const kPrSDKTimeSuiteVersion: u32 = 1;
pub const kPrSDKClipRenderSuite: &[u8; 27] = b"Premiere Clip Render Suite\0";
pub const kPrSDKClipRenderSuiteVersion: u32 = 3;
pub const kSPNoError: u32 = 0;
pub const kSPOutOfMemoryError: u32 = 4294967148;
pub const kSPBasicSuite: &[u8; 15] = b"SP Basic Suite\0";
pub const kSPBasicSuiteVersion: u32 = 4;
pub const PR_PISUITES_VERSION_1: u32 = 1;
pub const PR_PISUITES_VERSION_2: u32 = 2;
pub const PR_PISUITES_VERSION_3: u32 = 3;
pub const PR_PISUITES_VERSION_4: u32 = 4;
pub const PR_PISUITES_VERSION_5: u32 = 5;
pub const PR_PISUITES_VERSION_6: u32 = 6;
pub const PR_PISUITES_VERSION_7: u32 = 7;
pub const PR_PISUITES_VERSION_8: u32 = 8;
pub const PR_PISUITES_VERSION_9: u32 = 9;
pub const PR_PISUITES_VERSION: u32 = 9;
pub const kVideoFilterVersion: u32 = 12;
pub const kPrSDKErrorSuite: &[u8; 21] = b"Premiere Error Suite\0";
pub const kPrSDKErrorSuiteVersion1: u32 = 1;
pub const kPrSDKErrorSuiteVersion2: u32 = 2;
pub const kPrSDKErrorSuiteVersion3: u32 = 3;
pub const kPrSDKErrorSuiteVersion: u32 = 3;
pub const kPrSDKGPUDeviceSuite: &[u8; 27] = b"MediaCore GPU Device Suite\0";
pub const kPrSDKGPUDeviceSuiteVersion: u32 = 2;
pub const PrCUDAVersion: u32 = 10010;
pub const PrOpenCLVersion: u32 = 1000;
pub const kPrSDKAudioSuite: &[u8; 21] = b"Premiere Audio Suite\0";
pub const kPrSDKAudioSuiteVersion: u32 = 1;
pub const kMaxAudioChannelCount: u32 = 32;
pub const kPrSDKPlayModuleDeviceControlSuite: &[u8; 38] =
    b"Premiere Playmod Device Control Suite\0";
pub const kPrSDKPlayModuleDeviceControlSuiteVersion: u32 = 1;
pub const kPrSDKEndOfTimeline: u64 = 91445760000000000;
pub const PrSDKGPUFilterInterfaceVersion1: u32 = 1;
pub const PrSDKGPUFilterInterfaceVersion2: u32 = 2;
pub const PrSDKGPUFilterInterfaceVersion: u32 = 2;
pub const PrGPUFilterEntryPointName: &[u8; 16] = b"xGPUFilterEntry\0";
pub const kPrSDKGPUImageProcessingSuite: &[u8; 37] = b"MediaCore GPU Image Processing Suite\0";
pub const kPrSDKGPUImageProcessingSuiteVersion: u32 = 1;
pub const kPrSDKMemoryManagerSuite: &[u8; 30] = b"Premiere Memory Manager Suite\0";
pub const kPrSDKMemoryManagerSuiteVersion1: u32 = 1;
pub const kPrSDKMemoryManagerSuiteVersion2: u32 = 2;
pub const kPrSDKMemoryManagerSuiteVersion3: u32 = 3;
pub const kPrSDKMemoryManagerSuiteVersion4: u32 = 4;
pub const kPrSDKMemoryManagerSuiteVersion: u32 = 4;
pub const kPrSDKPixelFormatSuite: &[u8; 28] = b"Premiere Pixel Format Suite\0";
pub const kPrSDKPixelFormatSuiteVersion: u32 = 1;
pub const kPrSDKPPixSuite: &[u8; 20] = b"Premiere PPix Suite\0";
pub const kPrSDKPPixSuiteVersion: u32 = 1;
pub const kPrSDKPPix2Suite: &[u8; 22] = b"Premiere PPix 2 Suite\0";
pub const kPrSDKPPix2SuiteVersion1: u32 = 1;
pub const kPrSDKPPix2SuiteVersion2: u32 = 2;
pub const kPrSDKPPix2SuiteVersion3: u32 = 3;
pub const kPrSDKPPix2SuiteVersion: u32 = 3;
pub const kPrSRGBColorSpace: &[u8; 5] = b"sRGB\0";
pub const kPrRec601525ColorSpace: &[u8; 14] = b"BT.601 (NTSC)\0";
pub const kPrRec601625ColorSpace: &[u8; 13] = b"BT.601 (PAL)\0";
pub const kPrRec709: &[u8; 7] = b"BT.709\0";
pub const kPrRec709Scene: &[u8; 15] = b"BT.709 (Scene)\0";
pub const kPrRec709RGB: &[u8; 11] = b"BT.709 RGB\0";
pub const kPrRec709RGBScene: &[u8; 19] = b"BT.709 RGB (Scene)\0";
pub const kPrOverranged709: &[u8; 16] = b"BT.709 RGB Full\0";
pub const kPrOverranged709Scene: &[u8; 24] = b"BT.709 RGB Full (Scene)\0";
pub const kPrOverranged709Display: &[u8; 26] = b"BT.709 RGB Full (Display)\0";
pub const kPrRec2020: &[u8; 8] = b"BT.2020\0";
pub const kPrRec2020Scene: &[u8; 16] = b"BT.2020 (Scene)\0";
pub const kPrRec2020RGB: &[u8; 12] = b"BT.2020 RGB\0";
pub const kPrRec2020RGBScene: &[u8; 20] = b"BT.2020 RGB (Scene)\0";
pub const kPrOverranged2020: &[u8; 17] = b"BT.2020 RGB Full\0";
pub const kPrOverranged2020Scene: &[u8; 25] = b"BT.2020 RGB Full (Scene)\0";
pub const kPrOverranged2020Display: &[u8; 27] = b"BT.2020 RGB Full (Display)\0";
pub const kPrRec2100HLG: &[u8; 12] = b"BT.2100 HLG\0";
pub const kPrRec2100HLGScene: &[u8; 20] = b"BT.2100 HLG (Scene)\0";
pub const kPrRec2100HLGRGB: &[u8; 16] = b"BT.2100 HLG RGB\0";
pub const kPrRec2100HLGRGBScene: &[u8; 24] = b"BT.2100 HLG RGB (Scene)\0";
pub const kPrOverranged2100HLG: &[u8; 21] = b"BT.2100 HLG RGB Full\0";
pub const kPrOverranged2100HLGScene: &[u8; 29] = b"BT.2100 HLG RGB Full (Scene)\0";
pub const kPrOverranged2100HLGDisplay: &[u8; 31] = b"BT.2100 HLG RGB Full (Display)\0";
pub const kPrRec2100PQ: &[u8; 11] = b"BT.2100 PQ\0";
pub const kPrRec2100PQScene: &[u8; 19] = b"BT.2100 PQ (Scene)\0";
pub const kPrRec2100PQRGB: &[u8; 15] = b"BT.2100 PQ RGB\0";
pub const kPrRec2100PQRGBScene: &[u8; 23] = b"BT.2100 PQ RGB (Scene)\0";
pub const kPrOverranged2100PQ: &[u8; 20] = b"BT.2100 PQ RGB Full\0";
pub const kPrOverranged2100PQScene: &[u8; 28] = b"BT.2100 PQ RGB Full (Scene)\0";
pub const kPrOverranged2100PQDisplay: &[u8; 30] = b"BT.2100 PQ RGB Full (Display)\0";
pub const kPrDCDMXYZ: &[u8; 12] = b"DCDM X'Y'Z'\0";
pub const kPrSonySGamutSLog2: &[u8; 18] = b"Sony SGamut/SLog2\0";
pub const kPrSony2020SLog3: &[u8; 14] = b"BT.2020/SLog3\0";
pub const kPrSonySGamut3CineSLog3: &[u8; 24] = b"Sony SGamut3.Cine/SLog3\0";
pub const kPrSonySGamut3SLog3: &[u8; 19] = b"Sony SGamut3/SLog3\0";
pub const kPrWorkingColorSpace: &[u8; 20] = b"Working Color Space\0";
pub const kPrSDKPPixCacheSuite: &[u8; 26] = b"Premiere PPix Cache Suite\0";
pub const kPrSDKPPixCacheSuiteVersion1: u32 = 1;
pub const kPrSDKPPixCacheSuiteVersion2: u32 = 2;
pub const kPrSDKPPixCacheSuiteVersion3: u32 = 3;
pub const kPrSDKPPixCacheSuiteVersion4: u32 = 4;
pub const kPrSDKPPixCacheSuiteVersion5: u32 = 5;
pub const kPrSDKPPixCacheSuiteVersion6: u32 = 6;
pub const kPrSDKPPixCacheSuiteVersion7: u32 = 7;
pub const kPrSDKPPixCacheSuiteVersion8: u32 = 8;
pub const kPrSDKPPixCacheSuiteVersion: u32 = 8;
pub const kPrSDKPPixCreator2Suite: &[u8; 30] = b"Premiere PPix Creator 2 Suite\0";
pub const kPrSDKPPixCreator2SuiteVersion1: u32 = 1;
pub const kPrSDKPPixCreator2SuiteVersion2: u32 = 2;
pub const kPrSDKPPixCreator2SuiteVersion3: u32 = 3;
pub const kPrSDKPPixCreator2SuiteVersion4: u32 = 4;
pub const kPrSDKPPixCreator2SuiteVersion: u32 = 4;
pub const kPrSDKPPixCreatorSuite: &[u8; 28] = b"Premiere PPix Creator Suite\0";
pub const kPrSDKPPixCreatorSuiteVersion: u32 = 1;
pub const kPrSDKSequenceInfoSuite: &[u8; 30] = b"MediaCore Sequence Info Suite\0";
pub const kPrSDKSequenceInfoSuiteVersion: u32 = 6;
pub const kPrSDK_StreamLabel_Stereoscopic_Left: &[u8; 23] = b"ADBE.Stereoscopic.Left\0";
pub const kPrSDK_StreamLabel_Stereoscopic_Right: &[u8; 24] = b"ADBE.Stereoscopic.Right\0";
pub const kPrSDKSequenceRenderSuite: &[u8; 32] = b"MediaCore Sequence Render Suite\0";
pub const kPrSDKSequenceRenderSuiteVersion1: u32 = 1;
pub const kPrSDKSequenceRenderSuiteVersion2: u32 = 2;
pub const kPrSDKSequenceRenderSuiteVersion3: u32 = 3;
pub const kPrSDKSequenceRenderSuiteVersion4: u32 = 4;
pub const kPrSDKSequenceRenderSuiteVersion5: u32 = 5;
pub const kPrSDKSequenceRenderSuiteVersion6: u32 = 6;
pub const kPrSDKSequenceRenderSuiteVersion: u32 = 6;
pub const kPrSDKSmartRenderingSuite: &[u8; 32] = b"MediaCore Smart Rendering Suite\0";
pub const kPrSDKSmartRenderingSuiteVersion1: u32 = 1;
pub const kPrSDKSmartRenderingSuiteVersion2: u32 = 2;
pub const kPrSDKSmartRenderingSuiteVersion3: u32 = 3;
pub const kPrSDKSmartRenderingSuiteVersion: u32 = 3;
pub const kPrSDKStringSuite: &[u8; 22] = b"MediaCore StringSuite\0";
pub const kPrSDKStringSuiteVersion: u32 = 1;
pub const kPrSDKThreadedWorkSuite: &[u8; 29] = b"Premiere Threaded Work Suite\0";
pub const kPrSDKThreadedWorkSuiteVersion2: u32 = 2;
pub const kPrSDKThreadedWorkSuiteVersion3: u32 = 3;
pub const kVideoSegmentProperty_Media_ClipID: &[u8; 18] = b"MediaNode::ClipID\0";
pub const kVideoSegmentProperty_Media_ProxyClipID: &[u8; 23] = b"MediaNode::ProxyClipID\0";
pub const kVideoSegmentProperty_Media_InstanceString: &[u8; 31] =
    b"MediaNode::MediaInstanceString\0";
pub const kVideoSegmentProperty_Media_ProxyInstanceString: &[u8; 36] =
    b"MediaNode::ProxyMediaInstanceString\0";
pub const kVideoSegmentProperty_Media_ImplementationID: &[u8; 28] =
    b"MediaNode::ImplementationID\0";
pub const kVideoSegmentProperty_Media_StreamGroup: &[u8; 28] = b"MediaNode::MediaStreamGroup\0";
pub const kVideoSegmentProperty_Media_StreamLabel: &[u8; 28] = b"MediaNode::MediaStreamLabel\0";
pub const kVideoSegmentProperty_Media_IsDraft: &[u8; 24] = b"MediaNode::MediaIsDraft\0";
pub const kVideoSegmentProperty_Media_ModState: &[u8; 25] = b"MediaNode::MediaModState\0";
pub const kVideoSegmentProperty_Media_IsOffline: &[u8; 26] = b"MediaNode::MediaIsOffline\0";
pub const kVideoSegmentProperty_Media_IsPending: &[u8; 26] = b"MediaNode::MediaIsPending\0";
pub const kVideoSegmentProperty_Media_CaptioningID: &[u8; 29] = b"MediaNode::MediaCaptioningID\0";
pub const kVideoSegmentProperty_Media_StreamFrameRate: &[u8; 27] = b"MediaNode::StreamFrameRate\0";
pub const kVideoSegmentProperty_Media_StreamAlphaType: &[u8; 27] = b"MediaNode::StreamAlphaType\0";
pub const kVideoSegmentProperty_Media_StreamIgnoreAlpha: &[u8; 29] =
    b"MediaNode::StreamIgnoreAlpha\0";
pub const kVideoSegmentProperty_Media_StreamInvertAlpha: &[u8; 29] =
    b"MediaNode::StreamInvertAlpha\0";
pub const kVideoSegmentProperty_Media_StreamAlphaMatteColor: &[u8; 33] =
    b"MediaNode::StreamAlphaMatteColor\0";
pub const kVideoSegmentProperty_Media_StreamRemovePulldown: &[u8; 32] =
    b"MediaNode::StreamRemovePulldown\0";
pub const kVideoSegmentProperty_Media_StreamPixelAspectRatioNum: &[u8; 37] =
    b"MediaNode::StreamPixelAspectRatioNum\0";
pub const kVideoSegmentProperty_Media_StreamFrameWidth: &[u8; 28] =
    b"MediaNode::StreamFrameWidth\0";
pub const kVideoSegmentProperty_Media_StreamFrameHeight: &[u8; 29] =
    b"MediaNode::StreamFrameHeight\0";
pub const kVideoSegmentProperty_Media_StreamPixelAspectRatioDen: &[u8; 37] =
    b"MediaNode::StreamPixelAspectRatioDen\0";
pub const kVideoSegmentProperty_Media_StreamFieldType: &[u8; 27] = b"MediaNode::StreamFieldType\0";
pub const kVideoSegmentProperty_Media_StreamOpaqueData: &[u8; 28] =
    b"MediaNode::StreamOpaqueData\0";
pub const kVideoSegmentProperty_Media_ProxyStreamOpaqueData: &[u8; 33] =
    b"MediaNode::ProxyStreamOpaqueData\0";
pub const kVideoSegmentProperty_Media_StreamPullDownCadence: &[u8; 33] =
    b"MediaNode::StreamPullDownCadence\0";
pub const kVideoSegmentProperty_Media_StreamFrameVidSubType: &[u8; 33] =
    b"MediaNode::StreamFrameVidSubType\0";
pub const kVideoSegmentProperty_Media_StreamIsContinuousTime: &[u8; 62] =
    b"MediaNode::kVideoSegmentProperty_Media_StreamIsContinuousTime\0";
pub const kVideoSegmentProperty_Media_StreamIsRollCrawl: &[u8; 29] =
    b"MediaNode::StreamIsRollCrawl\0";
pub const kVideoSegmentProperty_Media_RollCrawlDuration: &[u8; 29] =
    b"MediaNode::RollCrawlDuration\0";
pub const kVideoSegmentProperty_Media_ContentStart: &[u8; 24] = b"MediaNode::ContentStart\0";
pub const kVideoSegmentProperty_Media_ContentEnd: &[u8; 22] = b"MediaNode::ContentEnd\0";
pub const kVideoSegmentProperty_Media_StartTimecodeOffset: &[u8; 31] =
    b"MediaNode::StartTimecodeOffset\0";
pub const kVideoSegmentProperty_Media_ProxyStartTimecodeOffset: &[u8; 36] =
    b"MediaNode::ProxyStartTimecodeOffset\0";
pub const kVideoSegmentProperty_Media_NestedSequenceHash: &[u8; 30] =
    b"MediaNode::NestedSequenceHash\0";
pub const kVideoSegmentProperty_Media_SelectedMulticamTrackFromNestedSequence: &[u8; 33] =
    b"MediaNode::SelectedMulticamTrack\0";
pub const kVideoSegmentProperty_Media_MulticamCameraOrderFromNestedSequence: &[u8; 31] =
    b"MediaNode::MulticamCameraOrder\0";
pub const kVideoSegmentProperty_Media_MulticamCamerasPerPage: &[u8; 34] =
    b"MediaNode::MulticamCamerasPerPage\0";
pub const kVideoSegmentProperty_Media_MulticamCurrentPage: &[u8; 31] =
    b"MediaNode::MulticamCurrentPage\0";
pub const kVideoSegmentProperty_Media_SelectedMulticamTrackTimelineID: &[u8; 43] =
    b"MediaNode::SelectedMulticamTrackTimelineID\0";
pub const kVideoSegmentProperty_Media_NestedSequenceTimelineID: &[u8; 36] =
    b"MediaNode::NestedSequenceTimelineID\0";
pub const kVideoSegmentProperty_Media_TrackItemIsMuted: &[u8; 28] =
    b"MediaNode::TrackItemIsMuted\0";
pub const kVideoSegmentProperty_Media_ClipSpeed: &[u8; 21] = b"MediaNode::ClipSpeed\0";
pub const kVideoSegmentProperty_Media_ClipBackwards: &[u8; 25] = b"MediaNode::ClipBackwards\0";
pub const kVideoSegmentProperty_Media_StreamFrameBlend: &[u8; 28] =
    b"MediaNode::StreamFrameBlend\0";
pub const kVideoSegmentProperty_Media_StreamTimeInterpolationType: &[u8; 39] =
    b"MediaNode::StreamTimeInterpolationType\0";
pub const kVideoSegmentProperty_Media_ClipScaleToFrameSize: &[u8; 32] =
    b"MediaNode::ClipScaleToFrameSize\0";
pub const kVideoSegmentProperty_Media_ClipScaleToFramePolicy: &[u8; 34] =
    b"MediaNode::ClipScaleToFramePolicy\0";
pub const kVideoSegmentProperty_Media_StreamReverseFieldDominance: &[u8; 39] =
    b"MediaNode::StreamReverseFieldDominance\0";
pub const kVideoSegmentProperty_Media_DeinterlaceAlways: &[u8; 29] =
    b"MediaNode::DeinterlaceAlways\0";
pub const kVideoSegmentProperty_Media_RemoveFlicker: &[u8; 25] = b"MediaNode::RemoveFlicker\0";
pub const kVideoSegmentProperty_Media_InterlaceConsecutiveFrames: &[u8; 38] =
    b"MediaNode::InterlaceConsecutiveFrames\0";
pub const kVideoSegmentProperty_Media_SequenceColorSpace: &[u8; 30] =
    b"MediaNode::SequenceColorSpace\0";
pub const kVideoSegmentProperty_Media_StreamColorSpace: &[u8; 28] =
    b"MediaNode::StreamColorSpace\0";
pub const kVideoSegmentProperty_Media_StreamInputLUTID: &[u8; 28] =
    b"MediaNode::StreamInputLUTID\0";
pub const kVideoSegmentProperty_Media_ScanlineOffsetToImproveVerticalCentering: &[u8; 52] =
    b"MediaNode::ScanlineOffsetToImproveVerticalCentering\0";
pub const kVideoSegmentProperty_Media_InPointMediaTimeAsTicks: &[u8; 35] =
    b"MediaNode::InPointMediaTimeAsTicks\0";
pub const kVideoSegmentProperty_Media_OutPointMediaTimeAsTicks: &[u8; 36] =
    b"MediaNode::OutPointMediaTimeAsTicks\0";
pub const kVideoSegmentProperty_Media_SequenceFieldType: &[u8; 29] =
    b"MediaNode::SequenceFieldType\0";
pub const kVideoSegmentProperty_Media_SequenceFrameRate: &[u8; 29] =
    b"MediaNode::SequenceFrameRate\0";
pub const kVideoSegmentProperty_Media_SequenceWidth: &[u8; 25] = b"MediaNode::SequenceWidth\0";
pub const kVideoSegmentProperty_Media_SequenceHeight: &[u8; 26] = b"MediaNode::SequenceHeight\0";
pub const kVideoSegmentProperty_Media_SequencePixelAspectRatioNum: &[u8; 39] =
    b"MediaNode::SequencePixelAspectRatioNum\0";
pub const kVideoSegmentProperty_Media_SequencePixelAspectRatioDen: &[u8; 39] =
    b"MediaNode::SequencePixelAspectRatioDen\0";
pub const kVideoSegmentProperty_Media_OrientationType: &[u8; 27] = b"MediaNode::OrientationType\0";
pub const kVideoSegmentProperty_Media_OrientationTypeProxy: &[u8; 32] =
    b"MediaNode::OrientationTypeProxy\0";
pub const kVideoSegmentProperty_Clip_ClipSpeed: &[u8; 20] = b"ClipNode::ClipSpeed\0";
pub const kVideoSegmentProperty_Clip_ClipBackwards: &[u8; 24] = b"ClipNode::ClipBackwards\0";
pub const kVideoSegmentProperty_Clip_TimeRemapping: &[u8; 24] = b"ClipNode::TimeRemapping\0";
pub const kVideoSegmentProperty_Clip_FrameHoldAtTime: &[u8; 26] = b"ClipNode::FrameHoldAtTime\0";
pub const kVideoSegmentProperty_Clip_FrameHoldFilters: &[u8; 27] = b"ClipNode::FrameHoldFilters\0";
pub const kVideoSegmentProperty_Clip_GrowingDuration: &[u8; 26] = b"ClipNode::GrowingDuration\0";
pub const kVideoSegmentProperty_Clip_FrameHoldDeinterlace: &[u8; 31] =
    b"ClipNode::FrameHoldDeinterlace\0";
pub const kVideoSegmentProperty_Clip_TrackID: &[u8; 18] = b"ClipNode::TrackID\0";
pub const kVideoSegmentProperty_Clip_TrackItemStartAsTicks: &[u8; 32] =
    b"ClipNode::TrackItemStartAsTicks\0";
pub const kVideoSegmentProperty_Clip_TrackItemEndAsTicks: &[u8; 30] =
    b"ClipNode::TrackItemEndAsTicks\0";
pub const kVideoSegmentProperty_Clip_EffectiveTrackItemStartAsTicks: &[u8; 41] =
    b"ClipNode::EffectiveTrackItemStartAsTicks\0";
pub const kVideoSegmentProperty_Clip_EffectiveTrackItemEndAsTicks: &[u8; 39] =
    b"ClipNode::EffectiveTrackItemEndAsTicks\0";
pub const kVideoSegmentProperty_Clip_AllowLinearCompositing: &[u8; 33] =
    b"ClipNode::AllowLinearCompositing\0";
pub const kVideoSegmentProperty_Clip_HasCaptions: &[u8; 22] = b"ClipNode::HasCaptions\0";
pub const kVideoSegmentProperty_Clip_UntrimmedDuration: &[u8; 28] =
    b"ClipNode::UntrimmedDuration\0";
pub const kVideoSegmentProperty_Multicam_SelectedTrack: &[u8; 28] =
    b"MulticamNode::SelectedTrack\0";
pub const kVideoSegmentProperty_Multicam_CameraOrder: &[u8; 26] = b"MulticamNode::CameraOrder\0";
pub const kVideoSegmentProperty_Multicam_CamerasPerPage: &[u8; 29] =
    b"MulticamNode::CamerasPerPage\0";
pub const kVideoSegmentProperty_Multicam_CurrentPage: &[u8; 26] = b"MulticamNode::CurrentPage\0";
pub const kVideoSegmentProperty_Multicam_ShowProgram: &[u8; 26] = b"MulticamNode::ShowProgram\0";
pub const kVideoSegmentProperty_Multicam_Recording: &[u8; 24] = b"MulticamNode::Recording\0";
pub const kVideoSegmentProperty_Multicam_IsNonMultiCam: &[u8; 28] =
    b"MulticamNode::IsNonMultiCam\0";
pub const kVideoSegmentProperty_Multicam_UseTimeRemapping: &[u8; 31] =
    b"MulticamNode::UseTimeRemapping\0";
pub const kVideoSegmentProperty_SolidColor_Color: &[u8; 22] = b"SolidColorNode::Color\0";
pub const kVideoSegmentProperty_Effect_FilterMatchName: &[u8; 28] =
    b"EffectNode::FilterMatchName\0";
pub const kVideoSegmentProperty_Effect_FilterOpaqueData: &[u8; 29] =
    b"EffectNode::FilterOpaqueData\0";
pub const kVideoSegmentProperty_Effect_FilterParams: &[u8; 25] = b"EffectNode::FilterParams\0";
pub const kVideoSegmentProperty_Effect_EffectDuration: &[u8; 27] = b"EffectNode::EffectDuration\0";
pub const kVideoSegmentProperty_Effect_RuntimeInstanceID: &[u8; 30] =
    b"EffectNode::RuntimeInstanceID\0";
pub const kVideoSegmentProperty_Effect_LayerInputHashes: &[u8; 29] =
    b"EffectNode::LayerInputHashes\0";
pub const kVideoSegmentProperty_Effect_StreamLabel: &[u8; 24] = b"EffectNode::StreamLabel\0";
pub const kVideoSegmentProperty_Effect_ClipName: &[u8; 21] = b"EffectNode::ClipName\0";
pub const kVideoSegmentProperty_Effect_MasterClipName: &[u8; 27] = b"EffectNode::MasterClipName\0";
pub const kVideoSegmentProperty_Effect_FileName: &[u8; 21] = b"EffectNode::FileName\0";
pub const kVideoSegmentProperty_Effect_SourceTrackClipNameHashes: &[u8; 38] =
    b"EffectNode::SourceTrackClipNameHashes\0";
pub const kVideoSegmentProperty_Transition_TransitionMatchName: &[u8; 36] =
    b"TransitionNode::TransitionMatchName\0";
pub const kVideoSegmentProperty_Transition_TransitionOpaqueData: &[u8; 37] =
    b"TransitionNode::TransitionOpaqueData\0";
pub const kVideoSegmentProperty_Transition_TransitionStartPosition: &[u8; 40] =
    b"TransitionNode::TransitionStartPosition\0";
pub const kVideoSegmentProperty_Transition_TransitionEndPosition: &[u8; 38] =
    b"TransitionNode::TransitionEndPosition\0";
pub const kVideoSegmentProperty_Transition_TransitionCenterPosition: &[u8; 41] =
    b"TransitionNode::TransitionCenterPosition\0";
pub const kVideoSegmentProperty_Transition_TransitionStartPercent: &[u8; 39] =
    b"TransitionNode::TransitionStartPercent\0";
pub const kVideoSegmentProperty_Transition_TransitionEndPercent: &[u8; 37] =
    b"TransitionNode::TransitionEndPercent\0";
pub const kVideoSegmentProperty_Transition_TransitionBorderWidth: &[u8; 38] =
    b"TransitionNode::TransitionBorderWidth\0";
pub const kVideoSegmentProperty_Transition_TransitionBorderColor: &[u8; 38] =
    b"TransitionNode::TransitionBorderColor\0";
pub const kVideoSegmentProperty_Transition_TransitionSwitchSources: &[u8; 40] =
    b"TransitionNode::TransitionSwitchSources\0";
pub const kVideoSegmentProperty_Transition_TransitionReverse: &[u8; 34] =
    b"TransitionNode::TransitionReverse\0";
pub const kVideoSegmentProperty_Transition_TransitionDirection: &[u8; 36] =
    b"TransitionNode::TransitionDirection\0";
pub const kVideoSegmentProperty_Transition_TransitionAntiAliasQuality: &[u8; 43] =
    b"TransitionNode::TransitionAntiAliasQuality\0";
pub const kVideoSegmentProperty_Transition_TransitionDuration: &[u8; 35] =
    b"TransitionNode::TransitionDuration\0";
pub const kVideoSegmentProperty_Transition_TransitionParams: &[u8; 33] =
    b"TransitionNode::TransitionParams\0";
pub const kVideoSegmentProperty_Transition_RuntimeInstanceID: &[u8; 34] =
    b"TransitionNode::RuntimeInstanceID\0";
pub const kVideoSegmentProperty_Adjustment_AdjustmentMediaIsOpaque: &[u8; 40] =
    b"AdjustmentNode::AdjustmentMediaIsOpaque\0";
pub const kVideoSegmentProperty_Adjustment_InvertAlpha: &[u8; 28] =
    b"AdjustmentNode::InvertAlpha\0";
pub const kPrSDKVideoSegmentSuite: &[u8; 30] = b"MediaCore Video Segment Suite\0";
pub const kPrSDKVideoSegmentSuiteVersion4: u32 = 4;
pub const kPrSDKVideoSegmentSuiteVersion5: u32 = 5;
pub const kPrSDKVideoSegmentSuiteVersion6: u32 = 6;
pub const kPrSDKVideoSegmentSuiteVersion7: u32 = 7;
pub const kPrSDKVideoSegmentSuiteVersion8: u32 = 8;
pub const kPrSDKVideoSegmentSuiteVersion9: u32 = 9;
pub const kPrSDKVideoSegmentSuiteVersion: u32 = 9;
pub const kVideoSegment_NodeType_Clip: &[u8; 23] = b"RenderableNodeClipImpl\0";
pub const kVideoSegment_NodeType_Compositor: &[u8; 29] = b"RenderableNodeCompositorImpl\0";
pub const kVideoSegment_NodeType_Disabled: &[u8; 27] = b"RenderableNodeDisabledImpl\0";
pub const kVideoSegment_NodeType_Effect: &[u8; 25] = b"RenderableNodeEffectImpl\0";
pub const kVideoSegment_NodeType_Transition: &[u8; 29] = b"RenderableNodeTransitionImpl\0";
pub const kVideoSegment_NodeType_Media: &[u8; 24] = b"RenderableNodeMediaImpl\0";
pub const kVideoSegment_NodeType_Preview: &[u8; 26] = b"RenderableNodePreviewImpl\0";
pub const kVideoSegment_NodeType_SolidColor: &[u8; 29] = b"RenderableNodeSolidColorImpl\0";
pub const kVideoSegment_NodeType_Multicam: &[u8; 27] = b"RenderableNodeMulticamImpl\0";
pub const kVideoSegment_NodeType_Adjustment: &[u8; 30] = b"RenderableNode_AdjustmentImpl\0";
pub const kVideoSegment_NodeType_AdjustmentEffect: &[u8; 36] =
    b"RenderableNode_AdjustmentEffectImpl\0";
pub const kPrSDKWindowSuite: &[u8; 22] = b"Premiere Window Suite\0";
pub const kPrSDKWindowSuiteVersion: u32 = 1;
pub const PF_Vers_BUILD_BITS: u32 = 511;
pub const PF_Vers_BUILD_SHIFT: u32 = 0;
pub const PF_Vers_STAGE_BITS: u32 = 3;
pub const PF_Vers_STAGE_SHIFT: u32 = 9;
pub const PF_Vers_BUGFIX_BITS: u32 = 15;
pub const PF_Vers_BUGFIX_SHIFT: u32 = 11;
pub const PF_Vers_SUBVERS_BITS: u32 = 15;
pub const PF_Vers_SUBVERS_SHIFT: u32 = 15;
pub const PF_Vers_VERS_BITS: u32 = 7;
pub const PF_Vers_VERS_SHIFT: u32 = 19;
pub const PF_Vers_VERS_HIGH_BITS: u32 = 15;
pub const PF_Vers_VERS_HIGH_SHIFT: u32 = 26;
pub const PF_Vers_VERS_LOW_SHIFT: u32 = 3;
pub const PF_AE234_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE234_PLUG_IN_SUBVERS: u32 = 28;
pub const PF_AE220_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE220_PLUG_IN_SUBVERS: u32 = 27;
pub const PF_AE184_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE184_PLUG_IN_SUBVERS: u32 = 26;
pub const PF_AE182_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE182_PLUG_IN_SUBVERS: u32 = 25;
pub const PF_AE180_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE180_PLUG_IN_SUBVERS: u32 = 24;
pub const PF_AE177_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE177_PLUG_IN_SUBVERS: u32 = 23;
pub const PF_AE176_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE176_PLUG_IN_SUBVERS: u32 = 22;
pub const PF_AE175_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE175_PLUG_IN_SUBVERS: u32 = 21;
pub const PF_AE171_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE171_PLUG_IN_SUBVERS: u32 = 20;
pub const PF_AE170_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE170_PLUG_IN_SUBVERS: u32 = 18;
pub const PF_AE161_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE161_PLUG_IN_SUBVERS: u32 = 17;
pub const PF_AE160_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE160_PLUG_IN_SUBVERS: u32 = 16;
pub const PF_AE151_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE151_PLUG_IN_SUBVERS: u32 = 15;
pub const PF_AE150_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE150_PLUG_IN_SUBVERS: u32 = 15;
pub const PF_AE142_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE142_PLUG_IN_SUBVERS: u32 = 14;
pub const PF_AE140_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE140_PLUG_IN_SUBVERS: u32 = 13;
pub const PF_AE138_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE138_PLUG_IN_SUBVERS: u32 = 11;
pub const PF_AE136_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE136_PLUG_IN_SUBVERS: u32 = 10;
pub const PF_AE135_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE135_PLUG_IN_SUBVERS: u32 = 9;
pub const PF_AE130_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE130_PLUG_IN_SUBVERS: u32 = 7;
pub const PF_AE122_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE122_PLUG_IN_SUBVERS: u32 = 6;
pub const PF_AE121_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE121_PLUG_IN_SUBVERS: u32 = 5;
pub const PF_AE120_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE120_PLUG_IN_SUBVERS: u32 = 4;
pub const PF_AE1101_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE1101_PLUG_IN_SUBVERS: u32 = 3;
pub const PF_AE110_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE110_PLUG_IN_SUBVERS: u32 = 2;
pub const PF_AE105_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE105_PLUG_IN_SUBVERS: u32 = 1;
pub const PF_AE100_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE100_PLUG_IN_SUBVERS: u32 = 0;
pub const PF_AE90_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE90_PLUG_IN_SUBVERS: u32 = 14;
pub const PF_AE80_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE80_PLUG_IN_SUBVERS: u32 = 13;
pub const PF_AE70_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE70_PLUG_IN_SUBVERS: u32 = 12;
pub const PF_AE65_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE65_PLUG_IN_SUBVERS: u32 = 11;
pub const PF_AE41_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE41_PLUG_IN_SUBVERS: u32 = 2;
pub const PF_AE40_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE40_PLUG_IN_SUBVERS: u32 = 1;
pub const PF_AE31_PLUG_IN_VERSION: u32 = 11;
pub const PF_AE31_PLUG_IN_SUBVERS: u32 = 6;
pub const PF_AE31_PLUG_IN_SUBVERS_STRICTIFY: u32 = 8;
pub const PF_AE_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE_PLUG_IN_SUBVERS: u32 = 28;
pub const PF_MAX_EFFECT_NAME_LEN: u32 = 31;
pub const PF_MAX_EFFECT_CATEGORY_NAME_LEN: u32 = 31;
pub const PF_MAX_EFFECT_PARAM_NAME_LEN: u32 = 31;
pub const PF_MAX_PARAM_DESCRIPTION_LEN: u32 = 31;
pub const PF_MAX_PARAM_VALUE_LEN: u32 = 31;
pub const PF_MAX_EFFECT_MSG_LEN: u32 = 255;
pub const PF_AE65_AND_EARLIER_MAX_NUM_EFFECT_PARAMS: u32 = 127;
pub const PF_MAX_WORLD_WIDTH: u32 = 30000;
pub const PF_MAX_WORLD_HEIGHT: u32 = 30000;
pub const PF_FIRST_ERR: u32 = 512;
pub const PF_Category_BLUR_AND_SHARPEN: &[u8; 15] = b"Blur & Sharpen\0";
pub const PF_Category_CHANNEL: &[u8; 8] = b"Channel\0";
pub const PF_Category_DISTORT: &[u8; 8] = b"Distort\0";
pub const PF_Category_IMAGE_CONTROL: &[u8; 14] = b"Image Control\0";
pub const PF_Category_KEYING: &[u8; 7] = b"Keying\0";
pub const PF_Category_PERSPECTIVE: &[u8; 12] = b"Perspective\0";
pub const PF_Category_STYLIZE: &[u8; 8] = b"Stylize\0";
pub const PF_Category_TEXT: &[u8; 5] = b"Text\0";
pub const PF_Category_VIDEO: &[u8; 6] = b"Video\0";
pub const PF_Category_TRANSITION: &[u8; 11] = b"Transition\0";
pub const PF_Category_AUDIO: &[u8; 6] = b"Audio\0";
pub const PF_Category_OTHER: &[u8; 6] = b"Other\0";
pub const PF_MAX_CHAN8: u32 = 255;
pub const PF_HALF_CHAN8: u32 = 128;
pub const PF_MAX_CHAN16: u32 = 32768;
pub const PF_HALF_CHAN16: u32 = 16384;
pub const PF_HUE_UNDEFINED: u32 = 2147483648;
pub const PF_CHANNEL_NAME_LEN: u32 = 63;
pub const PF_PI: f64 = 3.141592653589793;
pub const PF_2PI: f64 = 6.283185307179586;
pub const PF_HALF_PI: f64 = 1.5707963267948966;
pub const PF_E: f64 = 2.718281828459045;
pub const PF_SQRT2: f64 = 1.4142135623730951;
pub const PF_RAD_PER_DEGREE: f64 = 0.017453292519943295;
pub const PF_KernelFlag_2D: u32 = 0;
pub const PF_KernelFlag_1D: u32 = 1;
pub const PF_KernelFlag_UNNORMALIZED: u32 = 0;
pub const PF_KernelFlag_NORMALIZED: u32 = 2;
pub const PF_KernelFlag_CLAMP: u32 = 0;
pub const PF_KernelFlag_NO_CLAMP: u32 = 4;
pub const PF_KernelFlag_USE_LONG: u32 = 0;
pub const PF_KernelFlag_USE_CHAR: u32 = 8;
pub const PF_KernelFlag_USE_FIXED: u32 = 16;
pub const PF_KernelFlag_USE_UNDEFINED: u32 = 24;
pub const PF_KernelFlag_HORIZONTAL: u32 = 0;
pub const PF_KernelFlag_VERTICAL: u32 = 32;
pub const PF_KernelFlag_TRANSPARENT_BORDERS: u32 = 0;
pub const PF_KernelFlag_REPLICATE_BORDERS: u32 = 64;
pub const PF_KernelFlag_STRAIGHT_CONVOLVE: u32 = 0;
pub const PF_KernelFlag_ALPHA_WEIGHT_CONVOLVE: u32 = 128;
pub const PF_Iterations_ONCE_PER_PROCESSOR: i32 = -1;
pub const PF_Iteratations_ONCE_PER_PROCESSOR: i32 = -1;
pub const kPFPixelFormatSuite: &[u8; 22] = b"PF Pixel Format Suite\0";
pub const kPFPixelFormatSuiteVersion1: u32 = 1;
pub const kPFBackgroundFrameSuite: &[u8; 26] = b"PF Background Frame Suite\0";
pub const kPFBackgroundFrameSuiteVersion1: u32 = 1;
pub const kPFUtilitySuite: &[u8; 17] = b"PF Utility Suite\0";
pub const kPFUtilitySuiteVersion2: u32 = 2;
pub const kPFUtilitySuiteVersion3: u32 = 3;
pub const kPFUtilitySuiteVersion4: u32 = 4;
pub const kPFUtilitySuiteVersion5: u32 = 5;
pub const kPFUtilitySuiteVersion6: u32 = 6;
pub const kPFUtilitySuiteVersion7: u32 = 7;
pub const kPFUtilitySuiteVersion8: u32 = 8;
pub const kPFUtilitySuiteVersion9: u32 = 9;
pub const kPFUtilitySuiteVersion10: u32 = 10;
pub const kPFUtilitySuiteVersion11: u32 = 11;
pub const kPFUtilitySuiteVersion: u32 = 11;
pub const kPFSourceSettingsSuite: &[u8; 25] = b"PF Source Settings Suite\0";
pub const kPFSourceSettingsSuiteVersion1: u32 = 1;
pub const kPFSourceSettingsSuiteVersion2: u32 = 2;
pub const kPFSourceSettingsSuiteVersion: u32 = 2;
pub const kPFTransitionSuite: &[u8; 20] = b"PF Transition Suite\0";
pub const kPFTransitionSuiteVersion1: u32 = 1;
pub const kPFTransitionSuiteVersion2: u32 = 2;
pub const kPFTransitionSuiteVersion: u32 = 2;
pub const kPrSDKOpaqueEffectDataSuite: &[u8; 25] = b"Opaque Effect Data Suite\0";
pub const kPrSDKOpaqueEffectDataSuiteVersion2: u32 = 2;
pub const kPrSDKOpaqueEffectDataSuiteVersion: u32 = 2;
pub type ULONG = ::std::os::raw::c_ulong;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type LPBOOL = *mut BOOL;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type LPSTR = *mut CHAR;
pub type LPCSTR = *const CHAR;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type HRESULT = ::std::os::raw::c_long;
pub type LCID = DWORD;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type IID = GUID;
pub type CLSID = GUID;
pub type FMTID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: DWORD,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: DWORD,
    pub Control: DWORD,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type HGLOBAL = HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
pub type FILETIME = _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBITMAP__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDC = *mut HDC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPALETTE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HPALETTE = *mut HPALETTE__;
extern "C" {
    pub fn ProcessIdToSessionId(dwProcessId: DWORD, pSessionId: *mut DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_MEMORY_RANGE_ENTRY {
    pub VirtualAddress: PVOID,
    pub NumberOfBytes: SIZE_T,
}
pub type PWIN32_MEMORY_RANGE_ENTRY = *mut _WIN32_MEMORY_RANGE_ENTRY;
extern "C" {
    pub fn PrefetchVirtualMemory(
        hProcess: HANDLE,
        NumberOfEntries: ULONG_PTR,
        VirtualAddresses: PWIN32_MEMORY_RANGE_ENTRY,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegeCheck(
        ClientToken: HANDLE,
        RequiredPrivileges: PPRIVILEGE_SET,
        pfResult: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegedServiceAuditAlarmW(
        SubsystemName: LPCWSTR,
        ServiceName: LPCWSTR,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PrepareTape(hDevice: HANDLE, dwOperation: DWORD, bImmediate: BOOL) -> DWORD;
}
extern "C" {
    pub fn PrivilegedServiceAuditAlarmA(
        SubsystemName: LPCSTR,
        ServiceName: LPCSTR,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
pub type DLGPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> INT_PTR,
>;
extern "C" {
    pub fn PrintWindow(hwnd: HWND, hdcBlt: HDC, nFlags: UINT) -> BOOL;
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct DLGTEMPLATE {
    pub style: DWORD,
    pub dwExtendedStyle: DWORD,
    pub cdit: WORD,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub cx: ::std::os::raw::c_short,
    pub cy: ::std::os::raw::c_short,
}
pub type LPCDLGTEMPLATEA = *const DLGTEMPLATE;
pub type LPCDLGTEMPLATE = LPCDLGTEMPLATEA;
extern "C" {
    pub fn PrivateExtractIconsA(
        szFileName: LPCSTR,
        nIconIndex: ::std::os::raw::c_int,
        cxIcon: ::std::os::raw::c_int,
        cyIcon: ::std::os::raw::c_int,
        phicon: *mut HICON,
        piconid: *mut UINT,
        nIcons: UINT,
        flags: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn PrivateExtractIconsW(
        szFileName: LPCWSTR,
        nIconIndex: ::std::os::raw::c_int,
        cxIcon: ::std::os::raw::c_int,
        cyIcon: ::std::os::raw::c_int,
        phicon: *mut HICON,
        piconid: *mut UINT,
        nIcons: UINT,
        flags: UINT,
    ) -> UINT;
}
pub type byte = ::std::os::raw::c_uchar;
pub type cs_byte = byte;
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type LPCOLESTR = *const OLECHAR;
pub type DOUBLE = f64;
pub type SCODE = LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBLOB {
    pub cbSize: ULONG,
    pub pBlobData: *mut BYTE,
}
pub type BLOB = tagBLOB;
pub type DATE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagCY {
    pub __bindgen_anon_1: tagCY__bindgen_ty_1,
    pub int64: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCY__bindgen_ty_1 {
    pub Lo: ULONG,
    pub Hi: LONG,
}
pub type CY = tagCY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagDEC {
    pub wReserved: USHORT,
    pub __bindgen_anon_1: tagDEC__bindgen_ty_1,
    pub Hi32: ULONG,
    pub __bindgen_anon_2: tagDEC__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_1 {
    pub __bindgen_anon_1: tagDEC__bindgen_ty_1__bindgen_ty_1,
    pub signscale: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_1__bindgen_ty_1 {
    pub scale: BYTE,
    pub sign: BYTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_2 {
    pub __bindgen_anon_1: tagDEC__bindgen_ty_2__bindgen_ty_1,
    pub Lo64: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_2__bindgen_ty_1 {
    pub Lo32: ULONG,
    pub Mid32: ULONG,
}
pub type DECIMAL = tagDEC;
pub type BSTR = *mut OLECHAR;
pub type VARIANT_BOOL = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBSTRBLOB {
    pub cbSize: ULONG,
    pub pData: *mut BYTE,
}
pub type BSTRBLOB = tagBSTRBLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCLIPDATA {
    pub cbSize: ULONG,
    pub ulClipFmt: LONG,
    pub pClipData: *mut BYTE,
}
pub type CLIPDATA = tagCLIPDATA;
pub type VARTYPE = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSP {
    _unused: [u8; 0],
}
pub type HPROPSHEETPAGE = *mut _PSP;
pub type LPFNPSPCALLBACKA = ::std::option::Option<
    unsafe extern "C" fn(hwnd: HWND, uMsg: UINT, ppsp: *mut _PROPSHEETPAGEA) -> UINT,
>;
pub type LPFNPSPCALLBACKW = ::std::option::Option<
    unsafe extern "C" fn(hwnd: HWND, uMsg: UINT, ppsp: *mut _PROPSHEETPAGEW) -> UINT,
>;
pub type PROPSHEETPAGE_RESOURCE = LPCDLGTEMPLATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEA {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEA__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEA__bindgen_ty_2,
    pub pszTitle: LPCSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKA,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCSTR,
    pub pszHeaderSubTitle: LPCSTR,
    pub hActCtx: HANDLE,
    pub __bindgen_anon_3: _PROPSHEETPAGEA__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_1 {
    pub pszTemplate: LPCSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_3 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCSTR,
}
pub type PROPSHEETPAGEA_V4 = _PROPSHEETPAGEA;
pub type LPCPROPSHEETPAGEA_V4 = *const PROPSHEETPAGEA_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEW {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEW__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEW__bindgen_ty_2,
    pub pszTitle: LPCWSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKW,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCWSTR,
    pub pszHeaderSubTitle: LPCWSTR,
    pub hActCtx: HANDLE,
    pub __bindgen_anon_3: _PROPSHEETPAGEW__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_1 {
    pub pszTemplate: LPCWSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_3 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCWSTR,
}
pub type PROPSHEETPAGEW_V4 = _PROPSHEETPAGEW;
pub type LPCPROPSHEETPAGEW_V4 = *const PROPSHEETPAGEW_V4;
pub type LPCPROPSHEETPAGEA = LPCPROPSHEETPAGEA_V4;
pub type LPCPROPSHEETPAGEW = LPCPROPSHEETPAGEW_V4;
pub type PFNPROPSHEETCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: LPARAM) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERA_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERA_V2__bindgen_ty_1,
    pub pszCaption: LPCSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERA_V2__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERA_V2__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
    pub __bindgen_anon_4: _PROPSHEETHEADERA_V2__bindgen_ty_4,
    pub hplWatermark: HPALETTE,
    pub __bindgen_anon_5: _PROPSHEETHEADERA_V2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEA,
    pub phpage: *mut HPROPSHEETPAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_4 {
    pub hbmWatermark: HBITMAP,
    pub pszbmWatermark: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_5 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCSTR,
}
pub type PROPSHEETHEADERA_V2 = _PROPSHEETHEADERA_V2;
pub type LPCPROPSHEETHEADERA_V2 = *const PROPSHEETHEADERA_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERW_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERW_V2__bindgen_ty_1,
    pub pszCaption: LPCWSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERW_V2__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERW_V2__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
    pub __bindgen_anon_4: _PROPSHEETHEADERW_V2__bindgen_ty_4,
    pub hplWatermark: HPALETTE,
    pub __bindgen_anon_5: _PROPSHEETHEADERW_V2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEW,
    pub phpage: *mut HPROPSHEETPAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_4 {
    pub hbmWatermark: HBITMAP,
    pub pszbmWatermark: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_5 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCWSTR,
}
pub type PROPSHEETHEADERW_V2 = _PROPSHEETHEADERW_V2;
pub type LPCPROPSHEETHEADERW_V2 = *const PROPSHEETHEADERW_V2;
pub type LPCPROPSHEETHEADERA = LPCPROPSHEETHEADERA_V2;
pub type LPCPROPSHEETHEADERW = LPCPROPSHEETHEADERW_V2;
extern "C" {
    pub fn PropertySheetA(arg1: LPCPROPSHEETHEADERA) -> INT_PTR;
}
extern "C" {
    pub fn PropertySheetW(arg1: LPCPROPSHEETHEADERW) -> INT_PTR;
}
extern "C" {
    pub fn PrinterProperties(hWnd: HWND, hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn PrinterMessageBoxA(
        hPrinter: HANDLE,
        Error: DWORD,
        hWnd: HWND,
        pText: LPSTR,
        pCaption: LPSTR,
        dwType: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn PrinterMessageBoxW(
        hPrinter: HANDLE,
        Error: DWORD,
        hWnd: HWND,
        pText: LPWSTR,
        pCaption: LPWSTR,
        dwType: DWORD,
    ) -> DWORD;
}
pub const EPrintPropertyType_kPropertyTypeString: EPrintPropertyType = 1;
pub const EPrintPropertyType_kPropertyTypeInt32: EPrintPropertyType = 2;
pub const EPrintPropertyType_kPropertyTypeInt64: EPrintPropertyType = 3;
pub const EPrintPropertyType_kPropertyTypeByte: EPrintPropertyType = 4;
pub const EPrintPropertyType_kPropertyTypeTime: EPrintPropertyType = 5;
pub const EPrintPropertyType_kPropertyTypeDevMode: EPrintPropertyType = 6;
pub const EPrintPropertyType_kPropertyTypeSD: EPrintPropertyType = 7;
pub const EPrintPropertyType_kPropertyTypeNotificationReply: EPrintPropertyType = 8;
pub const EPrintPropertyType_kPropertyTypeNotificationOptions: EPrintPropertyType = 9;
pub const EPrintPropertyType_kPropertyTypeBuffer: EPrintPropertyType = 10;
pub type EPrintPropertyType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrintPropertyValue {
    pub ePropertyType: EPrintPropertyType,
    pub value: PrintPropertyValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PrintPropertyValue__bindgen_ty_1 {
    pub propertyByte: BYTE,
    pub propertyString: PWSTR,
    pub propertyInt32: LONG,
    pub propertyInt64: LONGLONG,
    pub propertyBlob: PrintPropertyValue__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintPropertyValue__bindgen_ty_1__bindgen_ty_1 {
    pub cbBuf: DWORD,
    pub pBuf: LPVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrintNamedProperty {
    pub propertyName: *mut WCHAR,
    pub propertyValue: PrintPropertyValue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintPropertiesCollection {
    pub numberOfProperties: ULONG,
    pub propertiesCollection: *mut PrintNamedProperty,
}
pub type LPUNKNOWN = *mut IUnknown;
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
    pub vtable_: *const IUnknown__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTATSTG {
    pub pwcsName: LPOLESTR,
    pub type_: DWORD,
    pub cbSize: ULARGE_INTEGER,
    pub mtime: FILETIME,
    pub ctime: FILETIME,
    pub atime: FILETIME,
    pub grfMode: DWORD,
    pub grfLocksSupported: DWORD,
    pub clsid: CLSID,
    pub grfStateBits: DWORD,
    pub reserved: DWORD,
}
pub type STATSTG = tagSTATSTG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStream {
    pub _base: ISequentialStream,
}
extern "C" {
    pub fn ProgIDFromCLSID(clsid: *const IID, lplpszProgID: *mut LPOLESTR) -> HRESULT;
}
pub type PROPVARIANT = tagPROPVARIANT;
extern "C" {
    pub fn PropVariantCopy(pvarDest: *mut PROPVARIANT, pvarSrc: *const PROPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn PropVariantClear(pvar: *mut PROPVARIANT) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATSTG {
    pub _base: IUnknown,
}
pub type SNB = *mut LPOLESTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStorage {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAYBOUND {
    pub cElements: ULONG,
    pub lLbound: LONG,
}
pub type SAFEARRAYBOUND = tagSAFEARRAYBOUND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAY {
    pub cDims: USHORT,
    pub fFeatures: USHORT,
    pub cbElements: ULONG,
    pub cLocks: ULONG,
    pub pvData: PVOID,
    pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
pub type SAFEARRAY = tagSAFEARRAY;
pub type LPSAFEARRAY = *mut SAFEARRAY;
pub type VARIANT = tagVARIANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT {
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1 {
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1,
    pub decVal: DECIMAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1 {
    pub vt: VARTYPE,
    pub wReserved1: WORD,
    pub wReserved2: WORD,
    pub wReserved3: WORD,
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub llVal: LONGLONG,
    pub lVal: LONG,
    pub bVal: BYTE,
    pub iVal: SHORT,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub bstrVal: BSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub parray: *mut SAFEARRAY,
    pub pbVal: *mut BYTE,
    pub piVal: *mut SHORT,
    pub plVal: *mut LONG,
    pub pllVal: *mut LONGLONG,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_PBOOL: *mut VARIANT_BOOL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut BSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut *mut SAFEARRAY,
    pub pvarVal: *mut VARIANT,
    pub byref: PVOID,
    pub cVal: CHAR,
    pub uiVal: USHORT,
    pub ulVal: ULONG,
    pub ullVal: ULONGLONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub pdecVal: *mut DECIMAL,
    pub pcVal: *mut CHAR,
    pub puiVal: *mut USHORT,
    pub pulVal: *mut ULONG,
    pub pullVal: *mut ULONGLONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub pvRecord: PVOID,
    pub pRecInfo: *mut IRecordInfo,
}
pub type VARIANTARG = VARIANT;
pub type DISPID = LONG;
pub type MEMBERID = DISPID;
pub type HREFTYPE = DWORD;
pub const tagTYPEKIND_TKIND_ENUM: tagTYPEKIND = 0;
pub const tagTYPEKIND_TKIND_RECORD: tagTYPEKIND = 1;
pub const tagTYPEKIND_TKIND_MODULE: tagTYPEKIND = 2;
pub const tagTYPEKIND_TKIND_INTERFACE: tagTYPEKIND = 3;
pub const tagTYPEKIND_TKIND_DISPATCH: tagTYPEKIND = 4;
pub const tagTYPEKIND_TKIND_COCLASS: tagTYPEKIND = 5;
pub const tagTYPEKIND_TKIND_ALIAS: tagTYPEKIND = 6;
pub const tagTYPEKIND_TKIND_UNION: tagTYPEKIND = 7;
pub const tagTYPEKIND_TKIND_MAX: tagTYPEKIND = 8;
pub type tagTYPEKIND = ::std::os::raw::c_int;
pub use self::tagTYPEKIND as TYPEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEDESC {
    pub __bindgen_anon_1: tagTYPEDESC__bindgen_ty_1,
    pub vt: VARTYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagTYPEDESC__bindgen_ty_1 {
    pub lptdesc: *mut tagTYPEDESC,
    pub lpadesc: *mut tagARRAYDESC,
    pub hreftype: HREFTYPE,
}
pub type TYPEDESC = tagTYPEDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagARRAYDESC {
    pub tdescElem: TYPEDESC,
    pub cDims: USHORT,
    pub rgbounds: [SAFEARRAYBOUND; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPARAMDESCEX {
    pub cBytes: ULONG,
    pub varDefaultValue: VARIANTARG,
}
pub type LPPARAMDESCEX = *mut tagPARAMDESCEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPARAMDESC {
    pub pparamdescex: LPPARAMDESCEX,
    pub wParamFlags: USHORT,
}
pub type PARAMDESC = tagPARAMDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIDLDESC {
    pub dwReserved: ULONG_PTR,
    pub wIDLFlags: USHORT,
}
pub type IDLDESC = tagIDLDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagELEMDESC {
    pub tdesc: TYPEDESC,
    pub __bindgen_anon_1: tagELEMDESC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagELEMDESC__bindgen_ty_1 {
    pub idldesc: IDLDESC,
    pub paramdesc: PARAMDESC,
}
pub type ELEMDESC = tagELEMDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEATTR {
    pub guid: GUID,
    pub lcid: LCID,
    pub dwReserved: DWORD,
    pub memidConstructor: MEMBERID,
    pub memidDestructor: MEMBERID,
    pub lpstrSchema: LPOLESTR,
    pub cbSizeInstance: ULONG,
    pub typekind: TYPEKIND,
    pub cFuncs: WORD,
    pub cVars: WORD,
    pub cImplTypes: WORD,
    pub cbSizeVft: WORD,
    pub cbAlignment: WORD,
    pub wTypeFlags: WORD,
    pub wMajorVerNum: WORD,
    pub wMinorVerNum: WORD,
    pub tdescAlias: TYPEDESC,
    pub idldescType: IDLDESC,
}
pub type TYPEATTR = tagTYPEATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDISPPARAMS {
    pub rgvarg: *mut VARIANTARG,
    pub rgdispidNamedArgs: *mut DISPID,
    pub cArgs: UINT,
    pub cNamedArgs: UINT,
}
pub type DISPPARAMS = tagDISPPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXCEPINFO {
    pub wCode: WORD,
    pub wReserved: WORD,
    pub bstrSource: BSTR,
    pub bstrDescription: BSTR,
    pub bstrHelpFile: BSTR,
    pub dwHelpContext: DWORD,
    pub pvReserved: PVOID,
    pub pfnDeferredFillIn:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut tagEXCEPINFO) -> HRESULT>,
    pub scode: SCODE,
}
pub type EXCEPINFO = tagEXCEPINFO;
pub const tagCALLCONV_CC_FASTCALL: tagCALLCONV = 0;
pub const tagCALLCONV_CC_CDECL: tagCALLCONV = 1;
pub const tagCALLCONV_CC_MSCPASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_PASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_MACPASCAL: tagCALLCONV = 3;
pub const tagCALLCONV_CC_STDCALL: tagCALLCONV = 4;
pub const tagCALLCONV_CC_FPFASTCALL: tagCALLCONV = 5;
pub const tagCALLCONV_CC_SYSCALL: tagCALLCONV = 6;
pub const tagCALLCONV_CC_MPWCDECL: tagCALLCONV = 7;
pub const tagCALLCONV_CC_MPWPASCAL: tagCALLCONV = 8;
pub const tagCALLCONV_CC_MAX: tagCALLCONV = 9;
pub type tagCALLCONV = ::std::os::raw::c_int;
pub use self::tagCALLCONV as CALLCONV;
pub const tagFUNCKIND_FUNC_VIRTUAL: tagFUNCKIND = 0;
pub const tagFUNCKIND_FUNC_PUREVIRTUAL: tagFUNCKIND = 1;
pub const tagFUNCKIND_FUNC_NONVIRTUAL: tagFUNCKIND = 2;
pub const tagFUNCKIND_FUNC_STATIC: tagFUNCKIND = 3;
pub const tagFUNCKIND_FUNC_DISPATCH: tagFUNCKIND = 4;
pub type tagFUNCKIND = ::std::os::raw::c_int;
pub use self::tagFUNCKIND as FUNCKIND;
pub const tagINVOKEKIND_INVOKE_FUNC: tagINVOKEKIND = 1;
pub const tagINVOKEKIND_INVOKE_PROPERTYGET: tagINVOKEKIND = 2;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUT: tagINVOKEKIND = 4;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUTREF: tagINVOKEKIND = 8;
pub type tagINVOKEKIND = ::std::os::raw::c_int;
pub use self::tagINVOKEKIND as INVOKEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagFUNCDESC {
    pub memid: MEMBERID,
    pub lprgscode: *mut SCODE,
    pub lprgelemdescParam: *mut ELEMDESC,
    pub funckind: FUNCKIND,
    pub invkind: INVOKEKIND,
    pub callconv: CALLCONV,
    pub cParams: SHORT,
    pub cParamsOpt: SHORT,
    pub oVft: SHORT,
    pub cScodes: SHORT,
    pub elemdescFunc: ELEMDESC,
    pub wFuncFlags: WORD,
}
pub type FUNCDESC = tagFUNCDESC;
pub const tagVARKIND_VAR_PERINSTANCE: tagVARKIND = 0;
pub const tagVARKIND_VAR_STATIC: tagVARKIND = 1;
pub const tagVARKIND_VAR_CONST: tagVARKIND = 2;
pub const tagVARKIND_VAR_DISPATCH: tagVARKIND = 3;
pub type tagVARKIND = ::std::os::raw::c_int;
pub use self::tagVARKIND as VARKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARDESC {
    pub memid: MEMBERID,
    pub lpstrSchema: LPOLESTR,
    pub __bindgen_anon_1: tagVARDESC__bindgen_ty_1,
    pub elemdescVar: ELEMDESC,
    pub wVarFlags: WORD,
    pub varkind: VARKIND,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARDESC__bindgen_ty_1 {
    pub oInst: ULONG,
    pub lpvarValue: *mut VARIANT,
}
pub type VARDESC = tagVARDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDispatch {
    pub _base: IUnknown,
}
pub const tagDESCKIND_DESCKIND_NONE: tagDESCKIND = 0;
pub const tagDESCKIND_DESCKIND_FUNCDESC: tagDESCKIND = 1;
pub const tagDESCKIND_DESCKIND_VARDESC: tagDESCKIND = 2;
pub const tagDESCKIND_DESCKIND_TYPECOMP: tagDESCKIND = 3;
pub const tagDESCKIND_DESCKIND_IMPLICITAPPOBJ: tagDESCKIND = 4;
pub const tagDESCKIND_DESCKIND_MAX: tagDESCKIND = 5;
pub type tagDESCKIND = ::std::os::raw::c_int;
pub use self::tagDESCKIND as DESCKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagBINDPTR {
    pub lpfuncdesc: *mut FUNCDESC,
    pub lpvardesc: *mut VARDESC,
    pub lptcomp: *mut ITypeComp,
}
pub type BINDPTR = tagBINDPTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeComp {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeInfo {
    pub _base: IUnknown,
}
pub const tagSYSKIND_SYS_WIN16: tagSYSKIND = 0;
pub const tagSYSKIND_SYS_WIN32: tagSYSKIND = 1;
pub const tagSYSKIND_SYS_MAC: tagSYSKIND = 2;
pub const tagSYSKIND_SYS_WIN64: tagSYSKIND = 3;
pub type tagSYSKIND = ::std::os::raw::c_int;
pub use self::tagSYSKIND as SYSKIND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTLIBATTR {
    pub guid: GUID,
    pub lcid: LCID,
    pub syskind: SYSKIND,
    pub wMajorVerNum: WORD,
    pub wMinorVerNum: WORD,
    pub wLibFlags: WORD,
}
pub type TLIBATTR = tagTLIBATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLib {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRecordInfo {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVersionedStream {
    pub guidVersion: GUID,
    pub pStream: *mut IStream,
}
pub type LPVERSIONEDSTREAM = *mut tagVersionedStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAC {
    pub cElems: ULONG,
    pub pElems: *mut CHAR,
}
pub type CAC = tagCAC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUB {
    pub cElems: ULONG,
    pub pElems: *mut UCHAR,
}
pub type CAUB = tagCAUB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAI {
    pub cElems: ULONG,
    pub pElems: *mut SHORT,
}
pub type CAI = tagCAI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUI {
    pub cElems: ULONG,
    pub pElems: *mut USHORT,
}
pub type CAUI = tagCAUI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAL {
    pub cElems: ULONG,
    pub pElems: *mut LONG,
}
pub type CAL = tagCAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUL {
    pub cElems: ULONG,
    pub pElems: *mut ULONG,
}
pub type CAUL = tagCAUL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAFLT {
    pub cElems: ULONG,
    pub pElems: *mut FLOAT,
}
pub type CAFLT = tagCAFLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCADBL {
    pub cElems: ULONG,
    pub pElems: *mut DOUBLE,
}
pub type CADBL = tagCADBL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACY {
    pub cElems: ULONG,
    pub pElems: *mut CY,
}
pub type CACY = tagCACY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCADATE {
    pub cElems: ULONG,
    pub pElems: *mut DATE,
}
pub type CADATE = tagCADATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABSTR {
    pub cElems: ULONG,
    pub pElems: *mut BSTR,
}
pub type CABSTR = tagCABSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABSTRBLOB {
    pub cElems: ULONG,
    pub pElems: *mut BSTRBLOB,
}
pub type CABSTRBLOB = tagCABSTRBLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABOOL {
    pub cElems: ULONG,
    pub pElems: *mut VARIANT_BOOL,
}
pub type CABOOL = tagCABOOL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCASCODE {
    pub cElems: ULONG,
    pub pElems: *mut SCODE,
}
pub type CASCODE = tagCASCODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAPROPVARIANT {
    pub cElems: ULONG,
    pub pElems: *mut PROPVARIANT,
}
pub type CAPROPVARIANT = tagCAPROPVARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAH {
    pub cElems: ULONG,
    pub pElems: *mut LARGE_INTEGER,
}
pub type CAH = tagCAH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUH {
    pub cElems: ULONG,
    pub pElems: *mut ULARGE_INTEGER,
}
pub type CAUH = tagCAUH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCALPSTR {
    pub cElems: ULONG,
    pub pElems: *mut LPSTR,
}
pub type CALPSTR = tagCALPSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCALPWSTR {
    pub cElems: ULONG,
    pub pElems: *mut LPWSTR,
}
pub type CALPWSTR = tagCALPWSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAFILETIME {
    pub cElems: ULONG,
    pub pElems: *mut FILETIME,
}
pub type CAFILETIME = tagCAFILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACLIPDATA {
    pub cElems: ULONG,
    pub pElems: *mut CLIPDATA,
}
pub type CACLIPDATA = tagCACLIPDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACLSID {
    pub cElems: ULONG,
    pub pElems: *mut CLSID,
}
pub type CACLSID = tagCACLSID;
pub type PROPVAR_PAD1 = WORD;
pub type PROPVAR_PAD2 = WORD;
pub type PROPVAR_PAD3 = WORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPVARIANT {
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPVARIANT__bindgen_ty_1 {
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1,
    pub decVal: DECIMAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1 {
    pub vt: VARTYPE,
    pub wReserved1: PROPVAR_PAD1,
    pub wReserved2: PROPVAR_PAD2,
    pub wReserved3: PROPVAR_PAD3,
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub cVal: CHAR,
    pub bVal: UCHAR,
    pub iVal: SHORT,
    pub uiVal: USHORT,
    pub lVal: LONG,
    pub ulVal: ULONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub hVal: LARGE_INTEGER,
    pub uhVal: ULARGE_INTEGER,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub filetime: FILETIME,
    pub puuid: *mut CLSID,
    pub pclipdata: *mut CLIPDATA,
    pub bstrVal: BSTR,
    pub bstrblobVal: BSTRBLOB,
    pub blob: BLOB,
    pub pszVal: LPSTR,
    pub pwszVal: LPWSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub pStream: *mut IStream,
    pub pStorage: *mut IStorage,
    pub pVersionedStream: LPVERSIONEDSTREAM,
    pub parray: LPSAFEARRAY,
    pub cac: CAC,
    pub caub: CAUB,
    pub cai: CAI,
    pub caui: CAUI,
    pub cal: CAL,
    pub caul: CAUL,
    pub cah: CAH,
    pub cauh: CAUH,
    pub caflt: CAFLT,
    pub cadbl: CADBL,
    pub cabool: CABOOL,
    pub cascode: CASCODE,
    pub cacy: CACY,
    pub cadate: CADATE,
    pub cafiletime: CAFILETIME,
    pub cauuid: CACLSID,
    pub caclipdata: CACLIPDATA,
    pub cabstr: CABSTR,
    pub cabstrblob: CABSTRBLOB,
    pub calpstr: CALPSTR,
    pub calpwstr: CALPWSTR,
    pub capropvar: CAPROPVARIANT,
    pub pcVal: *mut CHAR,
    pub pbVal: *mut UCHAR,
    pub piVal: *mut SHORT,
    pub puiVal: *mut USHORT,
    pub plVal: *mut LONG,
    pub pulVal: *mut ULONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub pdecVal: *mut DECIMAL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut BSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut LPSAFEARRAY,
    pub pvarVal: *mut PROPVARIANT,
}
extern "C" {
    pub fn PropStgNameToFmtId(oszName: LPOLESTR, pfmtid: *mut FMTID) -> HRESULT;
}
pub type LPPRINTHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
pub type LPSETUPHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub nFromPage: WORD,
    pub nToPage: WORD,
    pub nMinPage: WORD,
    pub nMaxPage: WORD,
    pub nCopies: WORD,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPrintHook: LPPRINTHOOKPROC,
    pub lpfnSetupHook: LPSETUPHOOKPROC,
    pub lpPrintTemplateName: LPCSTR,
    pub lpSetupTemplateName: LPCSTR,
    pub hPrintTemplate: HGLOBAL,
    pub hSetupTemplate: HGLOBAL,
}
pub type LPPRINTDLGA = *mut tagPDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub nFromPage: WORD,
    pub nToPage: WORD,
    pub nMinPage: WORD,
    pub nMaxPage: WORD,
    pub nCopies: WORD,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPrintHook: LPPRINTHOOKPROC,
    pub lpfnSetupHook: LPSETUPHOOKPROC,
    pub lpPrintTemplateName: LPCWSTR,
    pub lpSetupTemplateName: LPCWSTR,
    pub hPrintTemplate: HGLOBAL,
    pub hSetupTemplate: HGLOBAL,
}
pub type LPPRINTDLGW = *mut tagPDW;
extern "C" {
    pub fn PrintDlgA(pPD: LPPRINTDLGA) -> BOOL;
}
extern "C" {
    pub fn PrintDlgW(pPD: LPPRINTDLGW) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPRINTPAGERANGE {
    pub nFromPage: DWORD,
    pub nToPage: DWORD,
}
pub type PRINTPAGERANGE = tagPRINTPAGERANGE;
pub type LPPRINTPAGERANGE = *mut PRINTPAGERANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDEXA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub Flags2: DWORD,
    pub ExclusionFlags: DWORD,
    pub nPageRanges: DWORD,
    pub nMaxPageRanges: DWORD,
    pub lpPageRanges: LPPRINTPAGERANGE,
    pub nMinPage: DWORD,
    pub nMaxPage: DWORD,
    pub nCopies: DWORD,
    pub hInstance: HINSTANCE,
    pub lpPrintTemplateName: LPCSTR,
    pub lpCallback: LPUNKNOWN,
    pub nPropertyPages: DWORD,
    pub lphPropertyPages: *mut HPROPSHEETPAGE,
    pub nStartPage: DWORD,
    pub dwResultAction: DWORD,
}
pub type LPPRINTDLGEXA = *mut tagPDEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDEXW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub Flags2: DWORD,
    pub ExclusionFlags: DWORD,
    pub nPageRanges: DWORD,
    pub nMaxPageRanges: DWORD,
    pub lpPageRanges: LPPRINTPAGERANGE,
    pub nMinPage: DWORD,
    pub nMaxPage: DWORD,
    pub nCopies: DWORD,
    pub hInstance: HINSTANCE,
    pub lpPrintTemplateName: LPCWSTR,
    pub lpCallback: LPUNKNOWN,
    pub nPropertyPages: DWORD,
    pub lphPropertyPages: *mut HPROPSHEETPAGE,
    pub nStartPage: DWORD,
    pub dwResultAction: DWORD,
}
pub type LPPRINTDLGEXW = *mut tagPDEXW;
extern "C" {
    pub fn PrintDlgExA(pPD: LPPRINTDLGEXA) -> HRESULT;
}
extern "C" {
    pub fn PrintDlgExW(pPD: LPPRINTDLGEXW) -> HRESULT;
}
pub type csSDK_int8 = ::std::os::raw::c_schar;
pub type csSDK_int16 = ::std::os::raw::c_short;
pub type csSDK_int32 = ::std::os::raw::c_int;
pub type csSDK_int64 = ::std::os::raw::c_longlong;
pub type csSDK_uint8 = ::std::os::raw::c_uchar;
pub type csSDK_uint16 = ::std::os::raw::c_ushort;
pub type csSDK_uint32 = ::std::os::raw::c_uint;
pub type csSDK_uint64 = ::std::os::raw::c_ulonglong;
pub type csSDK_size_t = csSDK_uint64;
pub type PrMemoryPtr = *mut ::std::os::raw::c_char;
pub type PrMemoryHandle = *mut PrMemoryPtr;
pub type PrFourCC = csSDK_uint32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prRect {
    pub left: csSDK_int32,
    pub top: csSDK_int32,
    pub right: csSDK_int32,
    pub bottom: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prFPoint64 {
    pub x: f64,
    pub y: f64,
}
pub type prBool = csSDK_int32;
pub const kPrTrue: prBool = 1;
pub const kPrFalse: prBool = 0;
pub type prUTF8Char = csSDK_uint8;
pub type prWnd = HWND;
pub type prUTF16Char = u16;
pub type prInt64 = csSDK_int64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKString {
    pub opaque: [csSDK_int64; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKGuid {
    pub opaque: [csSDK_int64; 2usize],
}
pub type PrSDKColorSpaceID = PrSDKGuid;
extern "C" {
    pub static kPrSDKColorSpaceID_Invalid: PrSDKColorSpaceID;
}
pub type PrSDKLUTID = PrSDKGuid;
extern "C" {
    pub static kPrSDKLUTID_Invalid: PrSDKLUTID;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PPix {
    pub bounds: prRect,
    pub rowbytes: csSDK_int32,
    pub bitsperpixel: csSDK_int32,
    pub pix: *mut ::std::os::raw::c_void,
    pub reserved: [*mut ::std::os::raw::c_void; 32usize],
}
pub type PPixHand = *mut *mut PPix;
pub type prFieldType = csSDK_int32;
pub type PrTimelineID = csSDK_int32;
pub type PrClipID = csSDK_int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prPluginID {
    pub mGUID: [::std::os::raw::c_char; 37usize],
}
pub const PrParamType_kPrParamType_Int8: PrParamType = 1;
pub const PrParamType_kPrParamType_Int16: PrParamType = 2;
pub const PrParamType_kPrParamType_Int32: PrParamType = 3;
pub const PrParamType_kPrParamType_Int64: PrParamType = 4;
pub const PrParamType_kPrParamType_Float32: PrParamType = 5;
pub const PrParamType_kPrParamType_Float64: PrParamType = 6;
pub const PrParamType_kPrParamType_Bool: PrParamType = 7;
pub const PrParamType_kPrParamType_Point: PrParamType = 8;
pub const PrParamType_kPrParamType_Guid: PrParamType = 9;
pub const PrParamType_kPrParamType_PrMemoryPtr: PrParamType = 10;
pub const PrParamType_kPrParamType_MaxSize: PrParamType = -1;
pub type PrParamType = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct PrParam {
    pub mType: PrParamType,
    pub __bindgen_anon_1: PrParam__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union PrParam__bindgen_ty_1 {
    pub mInt8: csSDK_int8,
    pub mInt16: csSDK_int16,
    pub mInt32: csSDK_int32,
    pub mInt64: csSDK_int64,
    pub mFloat32: f32,
    pub mFloat64: f64,
    pub mBool: csSDK_uint8,
    pub mPoint: prFPoint64,
    pub mGuid: prPluginID,
    pub mMemoryPtr: PrMemoryPtr,
}
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_8u: PrPixelFormat = 1634887522;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_8u: PrPixelFormat = 1635349878;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_8u_709: PrPixelFormat = 1096373590;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_8u: PrPixelFormat = 1650946657;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_8u: PrPixelFormat = 2020763490;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_8u: PrPixelFormat = 2021225846;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_8u_709: PrPixelFormat = 930641270;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_8u: PrPixelFormat = 1650946680;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_8u: PrPixelFormat = 1886545762;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_8u: PrPixelFormat = 1887008118;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_8u_709: PrPixelFormat = 930116982;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_8u: PrPixelFormat = 1650946672;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_16u: PrPixelFormat = 1634887490;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_16u: PrPixelFormat = 1635349846;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_16u: PrPixelFormat = 1650946625;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_16u: PrPixelFormat = 2020763458;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_16u: PrPixelFormat = 1650946648;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_16u: PrPixelFormat = 1886545730;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_16u: PrPixelFormat = 1650946640;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_32f: PrPixelFormat = 1634879298;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_32f: PrPixelFormat = 1635341654;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_32f_709: PrPixelFormat = 1633244534;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_32f: PrPixelFormat = 1650938433;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_32f: PrPixelFormat = 2020755266;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_32f: PrPixelFormat = 2021217622;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_32f_709: PrPixelFormat = 930633046;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_32f: PrPixelFormat = 1650938456;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_32f: PrPixelFormat = 1886537538;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_32f: PrPixelFormat = 1886999894;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_32f_709: PrPixelFormat = 930108758;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_32f: PrPixelFormat = 1650938448;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_RGB_444_10u: PrPixelFormat = 826427218;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_YUYV_422_8u_601: PrPixelFormat = 846820729;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_YUYV_422_8u_709: PrPixelFormat = 863597945;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_8u_601: PrPixelFormat = 2037807477;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_8u_709: PrPixelFormat = 930511221;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_V210_422_10u_601: PrPixelFormat = 808530550;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_V210_422_10u_709: PrPixelFormat = 825307766;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_32f_601: PrPixelFormat = 2037799253;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_32f_709: PrPixelFormat = 930502997;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_32f_Linear: PrPixelFormat = 1281443650;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_32f_Linear: PrPixelFormat = 1282426690;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_32f_Linear: PrPixelFormat = 1282950978;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_32f_Linear: PrPixelFormat = 1281839681;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_32f_Linear: PrPixelFormat = 1281839696;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_32f_Linear: PrPixelFormat = 1281839704;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_PQ_709: PrPixelFormat = 928075840;
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_PQ_P3: PrPixelFormat = 1347506240;
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_PQ_2020: PrPixelFormat = 844189760;
pub const PrPixelFormat_PrPixelFormat_RGB_444_10u_HLG: PrPixelFormat = 827082816;
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_HLG: PrPixelFormat = 843860032;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601: PrPixelFormat =
    842102393;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601: PrPixelFormat =
    845772409;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1714517625;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1718187641;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709: PrPixelFormat =
    925988473;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709: PrPixelFormat =
    929658489;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1177646713;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1181316729;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601: PrPixelFormat =
    842102361;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601: PrPixelFormat =
    845772377;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1714517593;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1718187609;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709: PrPixelFormat =
    925988441;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709: PrPixelFormat =
    929658457;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1177646681;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1181316697;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    862549614;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    858879598;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 828995182;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 825325166;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    845772398;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    842102382;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 812217966;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 808547950;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    862549582;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    858879566;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 828995150;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 825325134;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    845772366;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    842102350;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 812217934;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 808547918;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_709:
    PrPixelFormat = 812200048;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_709:
    PrPixelFormat = 808530032;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_709_FullRange : PrPixelFormat = 1718169712 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_709_FullRange : PrPixelFormat = 1714499696 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020:
    PrPixelFormat = 812200016;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020:
    PrPixelFormat = 808530000;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_FullRange : PrPixelFormat = 1718169680 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_FullRange : PrPixelFormat = 1714499664 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR:
    PrPixelFormat = 812207952;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR:
    PrPixelFormat = 808537936;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR_FullRange : PrPixelFormat = 1718177616 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR_FullRange : PrPixelFormat = 1714507600 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG : PrPixelFormat = 812410960 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG : PrPixelFormat = 810305616 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG_FullRange : PrPixelFormat = 1718380624 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG_FullRange : PrPixelFormat = 1716275280 ;
pub const PrPixelFormat_PrPixelFormat_NTSCDV25: PrPixelFormat = 846100068;
pub const PrPixelFormat_PrPixelFormat_PALDV25: PrPixelFormat = 846231140;
pub const PrPixelFormat_PrPixelFormat_NTSCDV50: PrPixelFormat = 896431716;
pub const PrPixelFormat_PrPixelFormat_PALDV50: PrPixelFormat = 896562788;
pub const PrPixelFormat_PrPixelFormat_NTSCDV100_720p: PrPixelFormat = 929986148;
pub const PrPixelFormat_PrPixelFormat_PALDV100_720p: PrPixelFormat = 930117220;
pub const PrPixelFormat_PrPixelFormat_NTSCDV100_1080i: PrPixelFormat = 829322852;
pub const PrPixelFormat_PrPixelFormat_PALDV100_1080i: PrPixelFormat = 829453924;
pub const PrPixelFormat_PrPixelFormat_Raw: PrPixelFormat = 2004312434;
pub const PrPixelFormat_PrPixelFormat_Invalid: PrPixelFormat = 1717854562;
pub const PrPixelFormat_PrPixelFormat_Any: PrPixelFormat = 0;
#[doc = "\tPremiere supported pixel formats for RenderFrame and PPixs"]
pub type PrPixelFormat = ::std::os::raw::c_int;
pub type plugGetClipVideoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        frame: csSDK_int32,
        thePort: PPixHand,
        bounds: *mut prRect,
        flags: csSDK_int32,
        clipData: PrClipID,
    ) -> csSDK_int32,
>;
pub type plugGetWorkAreaFunc = ::std::option::Option<
    unsafe extern "C" fn(
        timelineData: PrTimelineID,
        workAreaStart: *mut csSDK_int32,
        workAreaEnd: *mut csSDK_int32,
    ) -> csSDK_int32,
>;
pub type plugGetCurrentTimebaseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        timelineData: PrTimelineID,
        scale: *mut csSDK_uint32,
        sampleSize: *mut csSDK_int32,
    ),
>;
pub type plugGetCurrentPosFunc =
    ::std::option::Option<unsafe extern "C" fn(timelineData: PrTimelineID) -> csSDK_int32>;
pub type plugGetPreviewFrameExFunc = ::std::option::Option<
    unsafe extern "C" fn(
        inTimelineData: PrTimelineID,
        inFrame: csSDK_int32,
        outRenderedFrame: *mut PPixHand,
        inFrameRect: *const prRect,
        inRequestedPixelFormatArray: *mut PrPixelFormat,
        inRequestedPixelFormatArrayCount: csSDK_int32,
        inPixelAspectRatioNumerator: csSDK_uint32,
        inPixelAspectRatioDenominator: csSDK_uint32,
        inAlwaysRender: bool,
    ) -> csSDK_int32,
>;
pub type plugGetClipVideoBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        inClipData: PrClipID,
        outBounds: *mut prRect,
        outPixelAspectRatioNumerator: *mut csSDK_uint32,
        outPixelAspectRatioDenominator: *mut csSDK_uint32,
    ) -> csSDK_int32,
>;
pub type plugGetClipVideoExFunc = ::std::option::Option<
    unsafe extern "C" fn(
        inFrame: csSDK_int32,
        outRenderedFrame: *mut PPixHand,
        inFrameRect: *const prRect,
        inRequestedPixelFormatArray: *const PrPixelFormat,
        inRequestedPixelFormatArrayCount: csSDK_int32,
        inPixelAspectRatioNumerator: csSDK_uint32,
        inPixelAspectRatioDenominator: csSDK_uint32,
        inClipData: PrClipID,
    ) -> csSDK_int32,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugTimelineFuncs {
    pub unused2: *mut ::std::os::raw::c_void,
    pub unused3: *mut ::std::os::raw::c_void,
    pub getClipVideo: plugGetClipVideoFunc,
    pub unused1: *mut ::std::os::raw::c_void,
    pub unused8: *mut ::std::os::raw::c_void,
    pub unused9: *mut ::std::os::raw::c_void,
    pub unused10: *mut ::std::os::raw::c_void,
    pub getWorkArea: plugGetWorkAreaFunc,
    pub unused7: *mut ::std::os::raw::c_void,
    pub unused4: *mut ::std::os::raw::c_void,
    pub getCurrentTimebase: plugGetCurrentTimebaseFunc,
    pub getCurrentPos: plugGetCurrentPosFunc,
    pub unused5: *mut ::std::os::raw::c_void,
    pub unused6: *mut ::std::os::raw::c_void,
    pub getPreviewFrameEx: plugGetPreviewFrameExFunc,
    pub getClipVideoBounds: plugGetClipVideoBoundsFunc,
    pub getClipVideoEx: plugGetClipVideoExFunc,
}
pub type PlugTimelineFuncsPtr = *mut PlugTimelineFuncs;
pub type prSuiteError = csSDK_int32;
pub const suiteError_NoError: prSuiteError = 0;
pub const suiteError_Fail: prSuiteError = -2147483648;
pub const suiteError_InvalidParms: prSuiteError = -2147483647;
pub const suiteError_OutOfMemory: prSuiteError = -2147483646;
pub const suiteError_InvalidCall: prSuiteError = -2147483645;
pub const suiteError_NotImplemented: prSuiteError = -2147483644;
pub const suiteError_IDNotValid: prSuiteError = -2147483643;
pub const suiteError_RenderPending: prSuiteError = 65536;
pub const suiteError_RenderedFrameNotFound: prSuiteError = 65537;
pub const suiteError_RenderedFrameCanceled: prSuiteError = 65538;
pub const suiteError_RenderInvalidPixelFormat: prSuiteError = -2147418112;
pub const suiteError_RenderCompletionProcNotSet: prSuiteError = -2147418111;
pub const suiteError_TimeRoundedAudioRate: prSuiteError = 131072;
pub const suiteError_CompilerCompileAbort: prSuiteError = 196609;
pub const suiteError_CompilerCompileDone: prSuiteError = 196610;
pub const suiteError_CompilerOutputFormatAccept: prSuiteError = 196612;
pub const suiteError_CompilerOutputFormatDecline: prSuiteError = 196613;
pub const suiteError_CompilerRebuildCutList: prSuiteError = 196614;
pub const suiteError_CompilerIterateCompiler: prSuiteError = 196615;
pub const suiteError_CompilerIterateCompilerDone: prSuiteError = 196616;
pub const suiteError_CompilerInternalErrorSilent: prSuiteError = 196617;
pub const suiteError_CompilerIterateCompilerCacheable: prSuiteError = 196618;
pub const suiteError_CompilerBadFormatIndex: prSuiteError = -2147287040;
pub const suiteError_CompilerInternalError: prSuiteError = -2147287039;
pub const suiteError_CompilerOutOfDiskSpace: prSuiteError = -2147287038;
pub const suiteError_CompilerBufferFull: prSuiteError = -2147287037;
pub const suiteError_CompilerErrOther: prSuiteError = -2147287036;
pub const suiteError_CompilerErrMemory: prSuiteError = -2147287035;
pub const suiteError_CompilerErrFileNotFound: prSuiteError = -2147287034;
pub const suiteError_CompilerErrTooManyOpenFiles: prSuiteError = -2147287033;
pub const suiteError_CompilerErrPermErr: prSuiteError = -2147287032;
pub const suiteError_CompilerErrOpenErr: prSuiteError = -2147287031;
pub const suiteError_CompilerErrInvalidDrive: prSuiteError = -2147287030;
pub const suiteError_CompilerErrDupFile: prSuiteError = -2147287029;
pub const suiteError_CompilerErrIo: prSuiteError = -2147287028;
pub const suiteError_CompilerErrInUse: prSuiteError = -2147287027;
pub const suiteError_CompilerErrCodecBadInput: prSuiteError = -2147287026;
pub const suiteError_ExporterSuspended: prSuiteError = -2147287025;
pub const suiteError_ExporterNoMoreFrames: prSuiteError = -2147287024;
pub const suiteError_FileBufferTooSmall: prSuiteError = -2147221504;
pub const suiteError_FileNotImportableFileType: prSuiteError = -2147221503;
pub const suiteError_LegacyInvalidVideoRate: prSuiteError = -2147155968;
pub const suiteError_PlayModuleAudioInitFailure: prSuiteError = -2147090432;
pub const suiteError_PlayModuleAudioIllegalPlaySetting: prSuiteError = -2147090431;
pub const suiteError_PlayModuleAudioNotInitialized: prSuiteError = -2147090430;
pub const suiteError_PlayModuleAudioNotStarted: prSuiteError = -2147090429;
pub const suiteError_PlayModuleAudioIllegalAction: prSuiteError = -2147090428;
pub const suiteError_PlayModuleDeviceControlSuiteIllegalCallSequence: prSuiteError = -2147024896;
pub const suiteError_MediaAcceleratorSuitePathNotFound: prSuiteError = -2146959360;
pub const suiteError_MediaAcceleratorSuiteRegisterFailure: prSuiteError = -2146959359;
pub const suiteError_RepositoryReadFailed: prSuiteError = -2146893824;
pub const suiteError_RepositoryWriteFailed: prSuiteError = -2146893823;
pub const suiteError_NotActivated: prSuiteError = -2146893822;
pub const suiteError_DataNotPresent: prSuiteError = -2146893821;
pub const suiteError_ServerCommunicationFailed: prSuiteError = -2146893820;
pub const suiteError_Internal: prSuiteError = -2146893819;
pub const suiteError_StringNotFound: prSuiteError = -2146828288;
pub const suiteError_StringBufferTooSmall: prSuiteError = -2146828287;
pub const suiteError_NoKeyframeAfterInTime: prSuiteError = -2146762752;
pub const suiteError_NoMoreData: prSuiteError = 786432;
pub const suiteError_InstanceDestroyed: prSuiteError = -2146631680;
pub const PrRenderQuality_kPrRenderQuality_Max: PrRenderQuality = 4;
pub const PrRenderQuality_kPrRenderQuality_High: PrRenderQuality = 3;
pub const PrRenderQuality_kPrRenderQuality_Medium: PrRenderQuality = 2;
pub const PrRenderQuality_kPrRenderQuality_Low: PrRenderQuality = 1;
pub const PrRenderQuality_kPrRenderQuality_Draft: PrRenderQuality = 0;
pub const PrRenderQuality_kPrRenderQuality_Invalid: PrRenderQuality = -1;
pub const PrRenderQuality_kPrRenderQuality_ForceEnumSize: PrRenderQuality = -1;
#[doc = "\tRender qualities"]
pub type PrRenderQuality = ::std::os::raw::c_int;
pub const PrPlaybackQuality_kPrPlaybackQuality_Invalid: PrPlaybackQuality = 4;
pub const PrPlaybackQuality_kPrPlaybackQuality_High: PrPlaybackQuality = 3;
pub const PrPlaybackQuality_kPrPlaybackQuality_Draft: PrPlaybackQuality = 2;
pub const PrPlaybackQuality_kPrPlaybackQuality_Auto: PrPlaybackQuality = 1;
pub const PrPlaybackQuality_kPrPlaybackQuality_ForceEnumSize: PrPlaybackQuality = -1;
#[doc = " Playback qualities"]
pub type PrPlaybackQuality = ::std::os::raw::c_int;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Invalid:
    PrPlaybackFractionalResolution = 6;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Sixteenth:
    PrPlaybackFractionalResolution = 5;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Eighth:
    PrPlaybackFractionalResolution = 4;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Quarter:
    PrPlaybackFractionalResolution = 3;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Half:
    PrPlaybackFractionalResolution = 2;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Full:
    PrPlaybackFractionalResolution = 1;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_ForceEnumSize:
    PrPlaybackFractionalResolution = -1;
#[doc = " Playback Fractional Resolutions"]
pub type PrPlaybackFractionalResolution = ::std::os::raw::c_int;
#[doc = "\tTime overview:\n\n\tPremiere uses a tick-based time counter that is stored in a signed\n\t64-bit integer. The current number of ticks per second must be retrieved\n\tusing the callback in this suite, but is guaranteed to be constant for\n\tthe duration of runtime."]
pub type PrTime = prInt64;
#[doc = "\tRatioTime is used where value that are not representable by ticks are needed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrRatioTime {
    pub mValue: prInt64,
    pub mScale: prInt64,
}
pub const PrVideoFrameRates_kVideoFrameRate_24Drop: PrVideoFrameRates = 1;
pub const PrVideoFrameRates_kVideoFrameRate_24: PrVideoFrameRates = 2;
pub const PrVideoFrameRates_kVideoFrameRate_PAL: PrVideoFrameRates = 3;
pub const PrVideoFrameRates_kVideoFrameRate_NTSC: PrVideoFrameRates = 4;
pub const PrVideoFrameRates_kVideoFrameRate_30: PrVideoFrameRates = 5;
pub const PrVideoFrameRates_kVideoFrameRate_PAL_HD: PrVideoFrameRates = 6;
pub const PrVideoFrameRates_kVideoFrameRate_NTSC_HD: PrVideoFrameRates = 7;
pub const PrVideoFrameRates_kVideoFrameRate_60: PrVideoFrameRates = 8;
pub const PrVideoFrameRates_kVideoFrameRate_Max: PrVideoFrameRates = -1;
pub type PrVideoFrameRates = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKTimeSuite {
    #[doc = "\tGet the current ticks per second. This is guaranteed to be constant for\n\tthe duration of runtime.\n\n\t@param\toutTickPerSec\ton return, the number of time ticks per second."]
    pub GetTicksPerSecond:
        ::std::option::Option<unsafe extern "C" fn(outTicksPerSec: *mut PrTime) -> prSuiteError>,
    #[doc = "\tGet the number of ticks in a video frame rate.\n\n\t@param\tinFrameRate\t\tan enum value for a video frame rate.\n\t@param\toutTicksPerFrame\ton return, the number of time ticks per frame."]
    pub GetTicksPerVideoFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoFrameRate: PrVideoFrameRates,
            outTicksPerFrame: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of ticks in an audio sample rate.\n\n\t@param\tinSampleRate\tthe audio sample rate as a float.\n\t@param\toutTicksPerSample\ton return, the number of time ticks per sample.\n\t@return\t\t\t\t\tkPrTimeSuite_RoundedAudioRate is returned if the requested\n\t\t\t\t\t\t\taudio sample rate is not an even divisor of the base tick\n\t\t\t\t\t\t\tcount and therefore times in this rate will not be exact."]
    pub GetTicksPerAudioSample: ::std::option::Option<
        unsafe extern "C" fn(inSampleRate: f32, outTicksPerSample: *mut PrTime) -> prSuiteError,
    >,
}
pub type PrRenderCacheType = csSDK_int32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ClipFrameFormat {
    pub inPixelFormat: PrPixelFormat,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKClipRenderSuite {
    #[doc = "\tDoes this clip support the clip render suite functions?\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutSupported\t\t\t\t\t\tIf true, the clip supports the ClipRenderSuite.\n\t@param\toutAsyncIOSupported\t\t\t\t\tIf true, the clip supports asynchronous IO.\n\t\t\t\t\t\t\t\t\t\t\t\tIf false, the clip does not directly support asynchronous IO,\n\t\t\t\t\t\t\t\t\t\t\t\thowever it is still legal to call InitiateAsyncRead.\n\t\t\t\t\t\t\t\t\t\t\t\tPass nil if you do not need this information."]
    pub SupportsClipRenderSuite: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            outSupported: *mut prBool,
            outAsyncIOSupported: *mut prBool,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip, find out the number of pixel formats natively supported\n\tby this clip.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutNumPixelFormats\t\t\t\t\tThe number of pixel formats."]
    pub GetNumPixelFormats: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            outNumPixelFormats: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip get a native pixel format. The pixel formats will be returned\n\tin index order based on preference. The maximum index can be determined by using\n\tGetNumPixelFormats().\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinIndex\t\t\t\t\t\t\t\tThe pixel format index.\n\t@param\toutPixelFormat\t\t\t\t\t\tThe pixel format."]
    pub GetPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inIndex: csSDK_int32,
            outPixelFormat: *mut PrPixelFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip and pixel format, find out the number of preferred\n\tframe sizes for this clip. A preferred frame size is a size which represents\n\ta \"native\" size of the media.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinPixelFormat\t\t\t\t\t\tThe pixel format to query for preferrred sizes.\n\t@param\toutNumPreferredFrameSizes\t\t\tThe number of sizes for this clip and pixel format."]
    pub GetNumPreferredFrameSizes: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inPixelFormat: PrPixelFormat,
            outNumPreferredFrameSizes: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip and pixel format, get a preferred size. The sizes will be returned\n\tin index order based on preference. The maximum index can be determined by using\n\tGetNumPreferredFrameSizes().\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinPixelFormat\t\t\t\t\t\tThe pixel format to query for preferrred sizes.\n\t@param\tinIndex\t\t\t\t\t\t\t\tThe preferred size index.\n\t@param\toutWidth\t\t\t\t\t\t\tThe width of the preferred size. 0 means any width.\n\t@param\toutHeight\t\t\t\t\t\t\tThe height of the preferred size. 0 means any height."]
    pub GetPreferredFrameSize: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inPixelFormat: PrPixelFormat,
            inIndex: csSDK_int32,
            outWidth: *mut csSDK_int32,
            outHeight: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tInitiate an asynchronous read for the specified frame. Note that you cannot specify\n\ta specific frame format here. The clip will prefetch whatever data possible to\n\tfacilitate a faster decode, and return.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\t@param\tinFormat\t\t\t\t\t\t\tThe preferred format for the frame."]
    pub InitiateAsyncRead: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inFrameTime: *const PrTime,
            inFormat: *mut ClipFrameFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tCancel an asynchronous read for the specified frame. Note that you cannot specify\n\ta specific frame format here.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\t@param\tinFormat\t\t\t\t\t\t\tThe preferred format for the frame."]
    pub CancelAsyncRead: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inFrameTime: *const PrTime,
            inFormat: *mut ClipFrameFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tFind a frame of a specific format in the cache. This function will first look\n\tfor a match in the supplied list of formats. If it does not find one, it will\n\task the importer to decode one out of cached raw data. It will not access the\n\tdisk for new raw data, so it will fail if the required data is not in the cache.\n\n\t@param  inClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\t@param\tinFormats\t\t\t\t\t\t\tAn array of formats that would be acceptable.\n\t\t\t\t\t\t\t\t\t\t\t\tEach format must be a combination of\n\t\t\t\t\t\t\t\t\t\t\t\tsupported pixel formats and preferred frame\n\t\t\t\t\t\t\t\t\t\t\t\tsizes. May be NULL, in which case in format\n\t\t\t\t\t\t\t\t\t\t\t\tmay be returned.\n\t@param\tinNumFormats\t\t\t\t\t\tThe number of items in inFormats. May be 0.\n\t@param\tinSynchronous\t\t\t\t\t\tIf true, the function will render the file from disk if necessary\n\t@param\toutFrame\t\t\t\t\t\t\tThe found frame. May be NULL if it was not found."]
    pub FindFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inFrameTime: *const PrTime,
            inFormats: *mut ClipFrameFormat,
            inNumFormats: csSDK_int32,
            inSynchronous: bool,
            outFrame: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tWhat is the field type of this clip? Added in version 2.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutFieldType\t\t\t\t\t\tSee prFieldType in PrSDKTypes.h"]
    pub GetClipFieldType: ::std::option::Option<
        unsafe extern "C" fn(inClipID: PrClipID, outFieldType: *mut prFieldType) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip, find out the number of custom pixel formats natively supported\n\tby this clip.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutNumPixelFormats\t\t\t\t\tThe number of pixel formats."]
    pub GetNumCustomPixelFormats: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            outNumPixelFormats: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip get a native pixel format. The pixel formats will be returned\n\tin index order based on preference. The maximum index can be determined by using\n\tGetNumPixelFormats().\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinIndex\t\t\t\t\t\t\t\tThe pixel format index.\n\t@param\toutPixelFormat\t\t\t\t\t\tThe pixel format."]
    pub GetCustomPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inIndex: csSDK_int32,
            outPixelFormat: *mut PrPixelFormat,
        ) -> prSuiteError,
    >,
}
#[doc = "!Indicates Data Group"]
pub const PrDSGroupChildType_kPrDSGroupType_GROUP: PrDSGroupChildType = 0;
#[doc = "!Indicates Dynamic Group"]
pub const PrDSGroupChildType_kPrDSGroupType_DYNAMIC_DATA: PrDSGroupChildType = 1;
#[doc = "!Indicates Static Group"]
pub const PrDSGroupChildType_kPrDSGroupType_STATIC_DATA: PrDSGroupChildType = 2;
#[doc = "!Indicates invalid entry"]
pub const PrDSGroupChildType_kPrDSGroupType_INVALID: PrDSGroupChildType = 3;
#[doc = "\tDefines data stream types"]
pub type PrDSGroupChildType = ::std::os::raw::c_int;
pub type plugNewPtrFunc =
    ::std::option::Option<unsafe extern "C" fn(size: csSDK_uint32) -> *mut ::std::os::raw::c_char>;
pub type plugSetPtrSizeFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut PrMemoryPtr, newsize: csSDK_uint32)>;
pub type plugGetPtrSizeFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_char) -> csSDK_int32>;
pub type plugDisposePtrFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_char)>;
pub type plugNewHandleFunc = ::std::option::Option<
    unsafe extern "C" fn(size: csSDK_uint32) -> *mut *mut ::std::os::raw::c_char,
>;
pub type plugSetHandleSizeFunc = ::std::option::Option<
    unsafe extern "C" fn(h: PrMemoryHandle, newsize: csSDK_uint32) -> csSDK_int16,
>;
pub type plugGetHandleSizeFunc =
    ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle) -> csSDK_int32>;
pub type plugDisposeHandleFunc = ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>;
pub type plugNewPtrClearFunc =
    ::std::option::Option<unsafe extern "C" fn(size: csSDK_uint32) -> *mut ::std::os::raw::c_char>;
pub type plugNewHandleClearFunc = ::std::option::Option<
    unsafe extern "C" fn(size: csSDK_uint32) -> *mut *mut ::std::os::raw::c_char,
>;
pub type plugLockHandleFunc = ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>;
pub type plugUnlockHandleFunc = ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugMemoryFuncs {
    pub newPtr: plugNewPtrFunc,
    pub setPtrSize: plugSetPtrSizeFunc,
    pub getPtrSize: plugGetPtrSizeFunc,
    pub disposePtr: plugDisposePtrFunc,
    pub newHandle: plugNewHandleFunc,
    pub setHandleSize: plugSetHandleSizeFunc,
    pub getHandleSize: plugGetHandleSizeFunc,
    pub disposeHandle: plugDisposeHandleFunc,
    pub newPtrClear: plugNewPtrClearFunc,
    pub newHandleClear: plugNewHandleClearFunc,
    pub lockHandle: plugLockHandleFunc,
    pub unlockHandle: plugUnlockHandleFunc,
}
pub type PlugMemoryFuncsPtr = *mut PlugMemoryFuncs;
pub type plugUpdateAllWindowsFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type plugGetMainWindFunc =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugWindowFuncs {
    pub updateAllWindows: plugUpdateAllWindowsFunc,
    pub getMainWnd: plugGetMainWindFunc,
}
pub type PlugWindowFuncsPtr = *mut PlugWindowFuncs;
pub type plugppixGetPixelsFunc =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand) -> *mut ::std::os::raw::c_char>;
pub type plugppixGetBoundsFunc =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand, bounds: *mut prRect)>;
pub type plugppixGetRowbytesFunc =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand) -> ::std::os::raw::c_int>;
pub type plugppixNewFunc =
    ::std::option::Option<unsafe extern "C" fn(bounds: *mut prRect) -> PPixHand>;
pub type plugppixDisposeFunc = ::std::option::Option<unsafe extern "C" fn(ppix: PPixHand)>;
pub type plugppixLockFunc = ::std::option::Option<unsafe extern "C" fn(pix: PPixHand)>;
pub type plugppixUnlockFunc = ::std::option::Option<unsafe extern "C" fn(pix: PPixHand)>;
pub type plugppixGetPixelAspectRatioFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pix: PPixHand,
        num: *mut csSDK_uint32,
        den: *mut csSDK_uint32,
    ) -> ::std::os::raw::c_int,
>;
pub type plugppixGetAlphaBounds =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand, alphaBounds: *mut prRect)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugppixFuncs {
    pub ppixGetPixels: plugppixGetPixelsFunc,
    pub ppixGetBounds: plugppixGetBoundsFunc,
    pub ppixGetRowbytes: plugppixGetRowbytesFunc,
    pub ppixNew: plugppixNewFunc,
    pub ppixDispose: plugppixDisposeFunc,
    pub ppixLockPixels: plugppixLockFunc,
    pub ppixUnlockPixels: plugppixUnlockFunc,
    pub ppixGetPixelAspectRatio: plugppixGetPixelAspectRatioFunc,
    pub ppixGetAlphaBounds: plugppixGetAlphaBounds,
}
pub type PlugppixFuncsPtr = *mut PlugppixFuncs;
pub type SPBoolean = ::std::os::raw::c_int;
pub type SPErr = ::std::os::raw::c_int;
#[doc = " @ingroup Suites\nThis suite provides basic memory management for PICA (the Adobe plug-in manager)\nand defines the basic functions for acquiring and releasing other suites.\n\nA suite consists of a list of function pointers. The application, or a\nplug-in that loads a suite, provides valid pointers when the suite is\nacquired. When a suite is not available, the pointers are set to the\naddress of the \\c #Undefined() function.\n\nDo not attempt to acquire a suite (other than the \\c #SPBlocksSuite)\nin response to a PICA access (\\c #kSPAccessCaller) or property\n(\\c #kSPPropertiesCaller) message. Most suites are unavailable\nduring these load and unload operations.\n\nYou can acquire all the suites you will need when your plug-in is first\nloaded, as long as you release them before your plug-in is unloaded.\nAt shutdown, however, it is most efficient to acquire only those\nsuites explicitly needed to shut down; for example, to free memory\nand save preferences.\n\nThe \\c SPBasicSuite itself is a part of the message data passed\nto your plug-in with any call. To access it from the message data structure:\n@code\nSPBasicSuite sBasic = message->d.basic;\nsBasic->function( )\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPBasicSuite {
    #[doc = " Acquires a function suite. Loads the suite if necessary,\nand increments its reference count. For example:\n@code\nSPErr error;\nSPBasicSuite *sBasic = message->d.basic;\nAIRandomSuite *sRandom;\nsBasic->AcquireSuite( kAIRandomSuite, kAIRandomVersion, &sRandom );\n@endcode\n@param name The suite name.\n@param version The suite version number.\n@param suite [out] A buffer in which to return the suite pointer.\n@see \\c #SPSuitesSuite::AcquireSuite()"]
    pub AcquireSuite: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
            suite: *mut *const ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " Decrements the reference count of a suite and unloads it when the\nreference count reaches 0.\n@param name The suite name.\n@param version The suite version number."]
    pub ReleaseSuite: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
        ) -> SPErr,
    >,
    #[doc = " Compares two strings for equality.\n@param token1 The first null-terminated string.\n@param token2 The second null-terminated string.\n@return True if the strings are the same, false otherwise."]
    pub IsEqual: ::std::option::Option<
        unsafe extern "C" fn(
            token1: *const ::std::os::raw::c_char,
            token2: *const ::std::os::raw::c_char,
        ) -> SPBoolean,
    >,
    #[doc = " Allocates a block of memory.\n@param size The number of bytes.\n@param block [out] A buffer in which to return the block pointer.\n@see \\c #SPBlocksSuite::AllocateBlock()"]
    pub AllocateBlock: ::std::option::Option<
        unsafe extern "C" fn(size: usize, block: *mut *mut ::std::os::raw::c_void) -> SPErr,
    >,
    #[doc = " Frees a block of memory allocated with \\c #AllocateBlock().\n@param block The block pointer.\n@see \\c #SPBlocksSuite::FreeBlock()"]
    pub FreeBlock:
        ::std::option::Option<unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> SPErr>,
    #[doc = " Reallocates a block previously allocated with \\c #AllocateBlock().\nIncreases the size without changing the location, if possible.\n@param block The block pointer.\n@param newSize The new number of bytes.\n@param newblock [out] A buffer in which to return the new block pointer.\n@see \\c #SPBlocksSuite::ReallocateBlock()"]
    pub ReallocateBlock: ::std::option::Option<
        unsafe extern "C" fn(
            block: *mut ::std::os::raw::c_void,
            newSize: usize,
            newblock: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " A function pointer for unloaded suites. This is a protective measure\nagainst other plug-ins that may mistakenly use the suite after they have\nreleased it.\n\nA plug-in that exports a suite should unload the suite's procedure pointers\nwhen it is unloaded, and restore them when the plug-in is reloaded.\n\\li On unload, replace the suite's procedure pointers\nwith the address of this function.\n\\li On reload, restore the suite's procedure\npointers with the updated addresses of their functions.\n\nFor example:\n@code\nSPErr UnloadSuite( MySuite *mySuite, SPAccessMessage *message ) {\nmySuite->functionA = (void *) message->d.basic->Undefined;\nmySuite->functionB = (void *) message->d.basic->Undefined;\n}\n\nSPErr ReloadSuite( MySuite *mySuite, SPAccessMessage *message ) {\nmySuite->functionA = functionA;\nmySuite->functionB = functionB;\n}\n@endcode"]
    pub Undefined: ::std::option::Option<unsafe extern "C" fn() -> SPErr>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prTimebaseRec {
    pub duration: csSDK_int32,
    pub scale: csSDK_int32,
    pub sampleSize: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prFileSpec {
    pub volID: ::std::os::raw::c_int,
    pub parID: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 256usize],
}
pub type plugGetSerialNumberFunc =
    ::std::option::Option<unsafe extern "C" fn(result: *mut ::std::os::raw::c_char)>;
pub type plugGetFileTimebaseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filespec: *mut prFileSpec,
        audioOnly: csSDK_int32,
        result: *mut prTimebaseRec,
    ) -> csSDK_int32,
>;
pub type plugGetFileVideoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filespec: *mut prFileSpec,
        frame: csSDK_int32,
        thePort: PPixHand,
        bounds: *mut prRect,
        flags: csSDK_int32,
    ) -> csSDK_int32,
>;
pub type plugGetFileAudioSecondFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filespec: *mut prFileSpec,
        num: csSDK_int32,
        buffer: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_short,
        audrate: csSDK_int32,
        speed: ::std::os::raw::c_short,
    ) -> csSDK_int32,
>;
pub type plugGetFileVideoBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(filespec: *mut prFileSpec, bounds: *mut prRect) -> csSDK_int32,
>;
pub type plugGetSPBasicSuiteFunc =
    ::std::option::Option<unsafe extern "C" fn() -> *mut SPBasicSuite>;
pub type plugGetFileExtStringFunc = ::std::option::Option<
    unsafe extern "C" fn(
        fileTypes: csSDK_uint32,
        inBuffer: *mut ::std::os::raw::c_char,
        inBufferSize: csSDK_uint32,
    ) -> csSDK_int32,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugUtilFuncs {
    pub unused1: *mut ::std::os::raw::c_void,
    pub getSerialNumber: plugGetSerialNumberFunc,
    pub getFileTimebase: plugGetFileTimebaseFunc,
    pub getFileVideo: plugGetFileVideoFunc,
    pub getFileAudioSecond: plugGetFileAudioSecondFunc,
    pub unused2: *mut ::std::os::raw::c_void,
    pub getFileVideoBounds: plugGetFileVideoBoundsFunc,
    pub getSPBasicSuite: plugGetSPBasicSuiteFunc,
    pub getFileExtString: plugGetFileExtStringFunc,
}
pub type PlugUtilFuncsPtr = *mut PlugUtilFuncs;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct piSuites {
    pub piInterfaceVer: ::std::os::raw::c_int,
    pub memFuncs: PlugMemoryFuncsPtr,
    pub windFuncs: PlugWindowFuncsPtr,
    pub ppixFuncs: PlugppixFuncsPtr,
    pub utilFuncs: PlugUtilFuncsPtr,
    pub timelineFuncs: PlugTimelineFuncsPtr,
}
pub type piSuitesPtr = *mut piSuites;
pub type Print2TapeProcPtr = ::std::option::Option<
    unsafe extern "C" fn(
        deviceHand: PrMemoryHandle,
        selector: ::std::os::raw::c_long,
    ) -> csSDK_int32,
>;
pub const PrDeviceSelector_dsInit: PrDeviceSelector = 0;
pub const PrDeviceSelector_dsSetup: PrDeviceSelector = 1;
pub const PrDeviceSelector_dsExecute: PrDeviceSelector = 2;
pub const PrDeviceSelector_dsCleanup: PrDeviceSelector = 3;
pub const PrDeviceSelector_dsRestart: PrDeviceSelector = 4;
pub const PrDeviceSelector_dsQuiet: PrDeviceSelector = 5;
pub const PrDeviceSelector_dsHasOptions: PrDeviceSelector = 6;
pub const PrDeviceSelector_dsSelector_Size: PrDeviceSelector = -1;
#[doc = "\tSelectors"]
pub type PrDeviceSelector = ::std::os::raw::c_int;
pub const PrTransitionReturnValue_esNoErr: PrTransitionReturnValue = 0;
pub const PrTransitionReturnValue_esBadFormatIndex: PrTransitionReturnValue = 1;
pub const PrTransitionReturnValue_esDoNotCacheOnLoad: PrTransitionReturnValue = 2;
pub const PrTransitionReturnValue_esUnsupported: PrTransitionReturnValue = -100;
pub const PrTransitionReturnValue_esErr_Size: PrTransitionReturnValue = -1;
#[doc = "\tError Definitions"]
pub type PrTransitionReturnValue = ::std::os::raw::c_int;
pub const PrFilterReturnValue_fsNoErr: PrFilterReturnValue = 0;
pub const PrFilterReturnValue_fsBadFormatIndex: PrFilterReturnValue = 1;
pub const PrFilterReturnValue_fsDoNotCacheOnLoad: PrFilterReturnValue = 2;
pub const PrFilterReturnValue_fsHasNoSetupDialog: PrFilterReturnValue = 3;
pub const PrFilterReturnValue_fsUnsupported: PrFilterReturnValue = -100;
pub const PrFilterReturnValue_fsErr_Size: PrFilterReturnValue = -1;
pub type PrFilterReturnValue = ::std::os::raw::c_int;
pub const PrTransitionSelector_esExecute: PrTransitionSelector = 0;
pub const PrTransitionSelector_esSetup: PrTransitionSelector = 1;
pub const PrTransitionSelector_esUnused1: PrTransitionSelector = 2;
pub const PrTransitionSelector_esUnused2: PrTransitionSelector = 3;
pub const PrTransitionSelector_esUnused3: PrTransitionSelector = 4;
pub const PrTransitionSelector_esDisposeData: PrTransitionSelector = 5;
pub const PrTransitionSelector_esCanHandlePAR: PrTransitionSelector = 6;
pub const PrTransitionSelector_esGetPixelFormatsSupported: PrTransitionSelector = 7;
pub const PrTransitionSelector_esCacheOnLoad: PrTransitionSelector = 8;
pub const PrTransitionSelector_esSelector_Size: PrTransitionSelector = -1;
#[doc = "\tSelectors"]
pub type PrTransitionSelector = ::std::os::raw::c_int;
pub const PrFilterSelector_fsExecute: PrFilterSelector = 0;
pub const PrFilterSelector_fsSetup: PrFilterSelector = 1;
pub const PrFilterSelector_fsAbout: PrFilterSelector = 2;
pub const PrFilterSelector_fsDisposeData: PrFilterSelector = 3;
pub const PrFilterSelector_fsCanHandlePAR: PrFilterSelector = 4;
pub const PrFilterSelector_fsInitSpec: PrFilterSelector = 5;
pub const PrFilterSelector_fsGetPixelFormatsSupported: PrFilterSelector = 6;
pub const PrFilterSelector_fsCacheOnLoad: PrFilterSelector = 7;
pub const PrFilterSelector_fsHasSetupDialog: PrFilterSelector = 8;
pub const PrFilterSelector_fsSelector_Size: PrFilterSelector = -1;
pub type PrFilterSelector = ::std::os::raw::c_int;
#[doc = "\tError overview:\n\n\tPlugins are allowed to send errors, warning, and information to 3 different\n\tcallbacks which will be handled by Premiere. For each, the plugin passes a string\n\tand a context ID from their plugin type (for instance, a CompilerID from the a\n\tcompiler). Then the plugin returns an error code defined in the appropriate\n\tplugin type header which will tell Premiere that there is an error with description\n\twaiting. Currently, Premiere concatenates all strings that it receives of each type\n\tuntil they can be displayed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKErrorSuite1 {
    #[doc = "\tSet the plugin error string for Premiere.\n\n\t@param\tinErrorString\tA NULL terminated string for the error. Premiere will\n\t\t\t\t\t\t\tcopy this string, so the caller can delete it after\n\t\t\t\t\t\t\tthe function returns.\n\t@param\tinContextID\t\tThe context ID passed to the plugin."]
    pub SetErrorString: ::std::option::Option<
        unsafe extern "C" fn(
            inErrorString: *const ::std::os::raw::c_char,
            inContextID: csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tSet the plugin error string for Premiere.\n\n\t@param\tinWarningString\tA NULL terminated string for the warning. Premiere will\n\t\t\t\t\t\t\tcopy this string, so the caller can delete it after\n\t\t\t\t\t\t\tthe function returns.\n\t@param\tinContextID\t\tThe context ID passed to the plugin."]
    pub SetWarningString: ::std::option::Option<
        unsafe extern "C" fn(
            inWarningString: *const ::std::os::raw::c_char,
            inContextID: csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tSet the plugin error string for Premiere.\n\n\t@param\tinInfoString\tA NULL terminated string for the info. Premiere will\n\t\t\t\t\t\t\tcopy this string, so the caller can delete it after\n\t\t\t\t\t\t\tthe function returns.\n\t@param\tinContextID\t\tThe context ID passed to the plugin."]
    pub SetInfoString: ::std::option::Option<
        unsafe extern "C" fn(
            inInfoString: *const ::std::os::raw::c_char,
            inContextID: csSDK_uint32,
        ) -> prSuiteError,
    >,
}
#[doc = "\tVersion 2 changes:\n\tThe suite has been streamlined for this release.  In addition, the\n\tstring has been broken into two parts, a title and a description.  This\n\tseparation works well with the new Events Window."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKErrorSuite2 {
    pub SetEventString: ::std::option::Option<
        unsafe extern "C" fn(
            eventType: csSDK_uint32,
            eventTitle: *const ::std::os::raw::c_char,
            eventDescription: *const ::std::os::raw::c_char,
        ) -> prSuiteError,
    >,
}
pub const PrSDKErrorSuite2_kEventTypeInformational: PrSDKErrorSuite2__bindgen_ty_1 = 1;
pub const PrSDKErrorSuite2_kEventTypeWarning: PrSDKErrorSuite2__bindgen_ty_1 = 2;
pub const PrSDKErrorSuite2_kEventTypeError: PrSDKErrorSuite2__bindgen_ty_1 = 3;
pub type PrSDKErrorSuite2__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "\tVersion 3 changes:\n\tAdd UTF16 string support"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKErrorSuite3 {
    pub SetEventStringUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            eventType: csSDK_uint32,
            eventTitle: *mut prUTF16Char,
            eventDescription: *mut prUTF16Char,
        ) -> prSuiteError,
    >,
}
pub const PrSDKErrorSuite3_kEventTypeInformational: PrSDKErrorSuite3__bindgen_ty_1 = 1;
pub const PrSDKErrorSuite3_kEventTypeWarning: PrSDKErrorSuite3__bindgen_ty_1 = 2;
pub const PrSDKErrorSuite3_kEventTypeError: PrSDKErrorSuite3__bindgen_ty_1 = 3;
pub const PrSDKErrorSuite3_kEventType_Mask: PrSDKErrorSuite3__bindgen_ty_1 = 255;
pub const PrSDKErrorSuite3_kEventFlag_DecodeError: PrSDKErrorSuite3__bindgen_ty_1 = 256;
pub const PrSDKErrorSuite3_kEventFlag_SubstitutedFrame: PrSDKErrorSuite3__bindgen_ty_1 = 512;
pub const PrSDKErrorSuite3_kEventFlag_ImportOperation: PrSDKErrorSuite3__bindgen_ty_1 = 1024;
pub type PrSDKErrorSuite3__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "\tVersion 3 changes:\n\tAdd UTF16 string support"]
pub type PrSDKErrorSuite = PrSDKErrorSuite3;
pub const PrGPUDeviceFramework_PrGPUDeviceFramework_CUDA: PrGPUDeviceFramework = 0;
pub const PrGPUDeviceFramework_PrGPUDeviceFramework_OpenCL: PrGPUDeviceFramework = 1;
pub const PrGPUDeviceFramework_PrGPUDeviceFramework_Metal: PrGPUDeviceFramework = 2;
pub type PrGPUDeviceFramework = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUDeviceInfo {
    pub outDeviceFramework: PrGPUDeviceFramework,
    pub outMeetsMinimumRequirementsForAcceleration: prBool,
    pub outPlatformHandle: *mut ::std::os::raw::c_void,
    pub outDeviceHandle: *mut ::std::os::raw::c_void,
    pub outContextHandle: *mut ::std::os::raw::c_void,
    pub outCommandQueueHandle: *mut ::std::os::raw::c_void,
    pub outOffscreenOpenGLContextHandle: *mut ::std::os::raw::c_void,
    pub outOffscreenOpenGLDeviceHandle: *mut ::std::os::raw::c_void,
}
#[doc = "\tAccess CUDA or OpenCL devices.\n\t\tAll CUDA usage is through the CUDA device API."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKGPUDeviceSuite {
    #[doc = "\tDevice enumeration"]
    pub GetDeviceCount: ::std::option::Option<
        unsafe extern "C" fn(outDeviceCount: *mut csSDK_uint32) -> prSuiteError,
    >,
    pub GetDeviceInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inSuiteVersion: csSDK_uint32,
            inDeviceIndex: csSDK_uint32,
            outDeviceInfo: *mut PrGPUDeviceInfo,
        ) -> prSuiteError,
    >,
    #[doc = "\tAcquire/release exclusive access to inDeviceIndex. All calls below this point generally require access be held.\n\tFor full GPU plugins (those that use a separate entry point for GPU rendering) exclusive access is always held.\n\tThese calls do not need to be made in that case.\n\t\tFor CUDA calls cuCtxPushCurrent/cuCtxPopCurrent on the current thread to manage the devices context."]
    pub AcquireExclusiveDeviceAccess:
        ::std::option::Option<unsafe extern "C" fn(inDeviceIndex: csSDK_uint32) -> prSuiteError>,
    pub ReleaseExclusiveDeviceAccess:
        ::std::option::Option<unsafe extern "C" fn(inDeviceIndex: csSDK_uint32) -> prSuiteError>,
    #[doc = "\tAll device memory must be allocated through this suite.\n\t\tPurge should be called only in emergency situations when working with GPU memory\n\t\t\tthat cannot be allocated through this suite (eg OpenGL memory).\n\t\tReturned pointer value represents memory allocated through cuMemAlloc or clCreateBuffer."]
    pub AllocateDeviceMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSizeInBytes: usize,
            outMemory: *mut *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub FreeDeviceMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inMemory: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PurgeDeviceMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inRequestedBytesToPurge: usize,
            outBytesPurged: *mut usize,
        ) -> prSuiteError,
    >,
    #[doc = "\tAll host (pinned) memory must be allocated through this suite.\n\t\tPurge should be called only in emergency situations when working with GPU memory\n\t\t\tthat cannot be allocated through this suite (eg OpenGL memory).\n\t\tReturned pointer value represents memory allocated through cuMemHostAlloc or malloc."]
    pub AllocateHostMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSizeInBytes: usize,
            outMemory: *mut *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub FreeHostMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inMemory: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PurgeHostMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inRequestedBytesToPurge: usize,
            outBytesPurged: *mut usize,
        ) -> prSuiteError,
    >,
    #[doc = "\tInformation on a GPU ppix. The following ppix functions may also be used:\n\t\t-PrSDKPPixSuite::Dispose\n\t\t-PrSDKPPixSuite::GetBounds\n\t\t-PrSDKPPixSuite::GetRowBytes\n\t\t-PrSDKPPixSuite::GetPixelAspectRatio\n\t\t-PrSDKPPixSuite::GetPixelFormat\n\t\t-PrSDKPPix2Suite::GetFieldOrder"]
    pub CreateGPUPPix: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inFieldType: prFieldType,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    pub GetGPUPPixData: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outData: *mut *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub GetGPUPPixDeviceIndex: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outDeviceIndex: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub GetGPUPPixSize: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outSize: *mut usize) -> prSuiteError,
    >,
}
pub const PrAudioSampleType_kPrAudioSampleType_8BitInt: PrAudioSampleType = 1;
pub const PrAudioSampleType_kPrAudioSampleType_8BitTwosInt: PrAudioSampleType = 2;
pub const PrAudioSampleType_kPrAudioSampleType_16BitInt: PrAudioSampleType = 3;
pub const PrAudioSampleType_kPrAudioSampleType_24BitInt: PrAudioSampleType = 4;
pub const PrAudioSampleType_kPrAudioSampleType_32BitInt: PrAudioSampleType = 5;
pub const PrAudioSampleType_kPrAudioSampleType_32BitFloat: PrAudioSampleType = 6;
pub const PrAudioSampleType_kPrAudioSampleType_64BitFloat: PrAudioSampleType = 7;
pub const PrAudioSampleType_kPrAudioSampleType_16BitIntBigEndian: PrAudioSampleType = 8;
pub const PrAudioSampleType_kPrAudioSampleType_24BitIntBigEndian: PrAudioSampleType = 9;
pub const PrAudioSampleType_kPrAudioSampleType_32BitIntBigEndian: PrAudioSampleType = 10;
pub const PrAudioSampleType_kPrAudioSampleType_32BitFloatBigEndian: PrAudioSampleType = 11;
pub const PrAudioSampleType_kPrAudioSampleType_Compressed: PrAudioSampleType = 12;
pub const PrAudioSampleType_kPrAudioSampleType_Packed: PrAudioSampleType = 13;
pub const PrAudioSampleType_kPrAudioSampleType_Other: PrAudioSampleType = 14;
pub const PrAudioSampleType_kPrAudioSampleType_Any: PrAudioSampleType = 15;
pub const PrAudioSampleType_kPrAudioSampleType_AudioPeakData: PrAudioSampleType = 16;
pub const PrAudioSampleType_kPrAudioSampleType_Max: PrAudioSampleType = -1;
#[doc = "\tAudio overview:\n\n\tAll audio calls to and from Premiere use arrays of buffers of 32-bit\n\tfloats to pass audio. Therefore all audio is not interleaved by channel.\n\tSo stereo audio looks like this:\n\n\tfloat* audio[2];\n\n\twhere audio[0] is the address of a buffer N samples long and audio[1]\n\tis the address of a second buffer N samples long. audio[0] contains\n\tthe left channel and audio[1] contains the right channel. N is called\n\tthe number of \"sample frames\" in the buffer. N will be the same no matter\n\thow many channels of audio are present in the buffer.\n\n\tBecause we use 32-bit floats for each audio sample, we can represent\n\tvalues above 0 dB during mixing. 0 dB corresponds to +/- 1.0 in the floating\n\tpoint. For symmetry in the int <--> float conversions, it is recommended\n\tyou use the utility functions below.  For example if you want to convert\n\ta single float to a 16-bit signed int, use ConvertAndInterleaveTo16BitInteger()\n\twith 1 channel and one sample frame.\n\n\tSince floats are the only audio format ever passed, there is no variable\n\tsample type or bit depth. However, when going back and forth to storage\n\tformats, it is necessary to give the user an indication of the sample\n\ttype in the storage. For this reason, the SDK includes AudioSampleType\n\twhich defines a variety of possible formats. Note that these are ONLY\n\tUSED FOR USER INTERFACE!\n\n\tIn general, any audio sample rate is supported. For this reason, we use\n\ta floating point number to represent audio sample rates. However, not all\n\trates will evenly divide into our time ticks per second, so for more\n\tunusual rates there will be quantization errors possible using PrTime.\n\n\tThe host currently supports 4 audio channels types: mono, stereo, 5.1 and 32 channels.\n\tStereo channel ordering is {kPrAudioChannelLabel_FrontLeft, kPrAudioChannelLabel_FrontRight}.\n\t5.1 channels ordering is\n\t\t{kPrAudioChannelLabel_FrontLeft,\t\t// L\n\t\t kPrAudioChannelLabel_FrontRight,\t\t// R\n\t\t kPrAudioChannelLabel_FrontCenter,\t\t// C\n\t\t kPrAudioChannelLabel_LowFrequency,\t\t// LFE\n\t\t kPrAudioChannelLabel_BackLeft,\t\t\t// Ls\n\t\t kPrAudioChannelLabel_BackRight}.\t\t// Rs\n\n\t32 channel ordering is all {kPrAudioChannelLabel_Discrete}"]
pub type PrAudioSampleType = ::std::os::raw::c_int;
pub const PrAudioChannelType_kPrAudioChannelType_Mono: PrAudioChannelType = 1;
pub const PrAudioChannelType_kPrAudioChannelType_Stereo: PrAudioChannelType = 2;
pub const PrAudioChannelType_kPrAudioChannelType_51: PrAudioChannelType = 3;
pub const PrAudioChannelType_kPrAudioChannelType_MaxChannel: PrAudioChannelType = 4;
pub const PrAudioChannelType_kPrAudioChannelType_Max: PrAudioChannelType = -1;
pub type PrAudioChannelType = ::std::os::raw::c_int;
pub const PrAudioDataType_kPrAudioDataType_Float32: PrAudioDataType = 1;
pub const PrAudioDataType_kPrAudioDataType_Int32: PrAudioDataType = 2;
pub const PrAudioDataType_kPrAudioDataType_PeakAudio: PrAudioDataType = 3;
#[doc = "\tThis is not the sample type of the underlying audio - this is the sample type\n\tthat is returned in the calls that support variable audio types. If the type is not\n\texplicitly called out as variable, then it is Float32."]
pub type PrAudioDataType = ::std::os::raw::c_int;
pub type PrAudioSample = prInt64;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Discrete: PrAudioChannelLabel = 0;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontLeft: PrAudioChannelLabel = 100;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontRight: PrAudioChannelLabel = 101;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontCenter: PrAudioChannelLabel = 102;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LowFrequency: PrAudioChannelLabel = 103;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BackLeft: PrAudioChannelLabel = 104;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BackRight: PrAudioChannelLabel = 105;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BackCenter: PrAudioChannelLabel = 106;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontLeftOfCenter: PrAudioChannelLabel = 107;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontRightOfCenter: PrAudioChannelLabel = 108;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_SideLeft: PrAudioChannelLabel = 109;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_SideRight: PrAudioChannelLabel = 110;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopCenter: PrAudioChannelLabel = 111;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopFrontLeft: PrAudioChannelLabel = 112;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopFrontRight: PrAudioChannelLabel = 113;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopFrontCenter: PrAudioChannelLabel = 114;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopBackLeft: PrAudioChannelLabel = 115;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopBackRight: PrAudioChannelLabel = 116;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopBackCenter: PrAudioChannelLabel = 117;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontLeftWide: PrAudioChannelLabel = 118;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontRightWide: PrAudioChannelLabel = 119;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LeftHeight: PrAudioChannelLabel = 127;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RightHeight: PrAudioChannelLabel = 128;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RearSurroundLeft: PrAudioChannelLabel = 129;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RearSurroundRight: PrAudioChannelLabel = 130;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LFE2: PrAudioChannelLabel = 131;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LeftTotal: PrAudioChannelLabel = 132;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RightTotal: PrAudioChannelLabel = 133;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_W: PrAudioChannelLabel = 134;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_X: PrAudioChannelLabel = 135;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_Y: PrAudioChannelLabel = 136;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_Z: PrAudioChannelLabel = 137;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BottomFrontLeft: PrAudioChannelLabel = 138;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BottomFrontCenter: PrAudioChannelLabel = 139;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BottomFrontRight: PrAudioChannelLabel = 140;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_ProximityLeft: PrAudioChannelLabel = 141;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_ProximityRight: PrAudioChannelLabel = 142;
pub type PrAudioChannelLabel = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKAudioSuite {
    #[doc = "\tThese are a variety of audio buffer conversion routines to convert an array\n\tof floating point buffers into interleaved audio of a specific type.\n\n\t@param\tinSource\t\tAn array of float buffers holding audio.\n\t@param\tinDestination\tA single buffer to hold the converted, interleaved audio.\n\t\t\t\t\t\t\tinDestination must be at least inNumChannels * sizeof(destinationFormat) *\n\t\t\t\t\t\t\tinNumSampleFrames bytes long.\n\t@param\tinNumChannels\tThe number of channels in inSource.\n\t@param\tinNumSampleFrames\tThe number of samples in each buffer in inSource."]
    pub ConvertAndInterleaveTo8BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut ::std::os::raw::c_char,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub ConvertAndInterleaveTo16BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut ::std::os::raw::c_short,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub ConvertAndInterleaveTo24BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut ::std::os::raw::c_char,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub ConvertAndInterleaveTo32BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut csSDK_int32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    #[doc = "\tThese routines provide the reverse of the routines above, converting and\n\tuninterleaving a single buffer in a specified type.\n\n\t@param\tinSource\t\tA single buffer holding the orignal, interleaved audio.\n\t@param\tinDestination\tAn array of float buffers holding audio. There must be inNumChannels\n\t\t\t\t\t\t\tbuffers allocated in the array, and each must be at least\n\t\t\t\t\t\t\tinNumSampleFrames * sizeof(float) bytes long.\n\t@param\tinNumChannels\tThe number of channels in inSource.\n\t@param\tinNumSampleFrames\tThe number of samples in each buffer in inSource."]
    pub UninterleaveAndConvertFrom8BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut ::std::os::raw::c_char,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub UninterleaveAndConvertFrom16BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut ::std::os::raw::c_short,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub UninterleaveAndConvertFrom24BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut ::std::os::raw::c_char,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub UninterleaveAndConvertFrom32BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut csSDK_int32,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
}
pub const PrActivationEvent_PrActivationEvent_Unspecified: PrActivationEvent = 0;
pub const PrActivationEvent_PrActivationEvent_RecorderActivated: PrActivationEvent = 1;
pub const PrActivationEvent_PrActivationEvent_PlayerActivated: PrActivationEvent = 2;
pub const PrActivationEvent_PrActivationEvent_ApplicationLostFocus: PrActivationEvent = 3;
pub const PrActivationEvent_PrActivationEvent_ForceSize: PrActivationEvent = -1;
#[doc = "\tPrActivationEvent - Describes the event that caused activation/deactivation to occur"]
pub type PrActivationEvent = ::std::os::raw::c_int;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Undefined:
    PrRenderCaptionStreamFormat = 0;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Open:
    PrRenderCaptionStreamFormat = 1;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_OP_42:
    PrRenderCaptionStreamFormat = 10;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_OP_47:
    PrRenderCaptionStreamFormat = 11;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC1:
    PrRenderCaptionStreamFormat = 20;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC2:
    PrRenderCaptionStreamFormat = 21;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC3:
    PrRenderCaptionStreamFormat = 22;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC4:
    PrRenderCaptionStreamFormat = 23;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text1:
    PrRenderCaptionStreamFormat = 24;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text2:
    PrRenderCaptionStreamFormat = 25;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text3:
    PrRenderCaptionStreamFormat = 26;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text4:
    PrRenderCaptionStreamFormat = 27;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_XDS:
    PrRenderCaptionStreamFormat = 28;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service1:
    PrRenderCaptionStreamFormat = 40;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service2:
    PrRenderCaptionStreamFormat = 41;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service3:
    PrRenderCaptionStreamFormat = 42;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service4:
    PrRenderCaptionStreamFormat = 43;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service5:
    PrRenderCaptionStreamFormat = 44;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service6:
    PrRenderCaptionStreamFormat = 45;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Teletext_Level1:
    PrRenderCaptionStreamFormat = 50;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Teletext_Level2:
    PrRenderCaptionStreamFormat = 51;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Open_Subtitling:
    PrRenderCaptionStreamFormat = 52;
#[doc = "\tDefines the Caption Stream format to render"]
pub type PrRenderCaptionStreamFormat = ::std::os::raw::c_int;
pub type PlayModuleDeviceID = csSDK_int32;
pub const kPrDeviceControlResult_Success: prSuiteError = 0;
pub const kPrDeviceControlResult_GeneralError: prSuiteError = -1;
pub const kPrDeviceControlResult_IllegalCallSequence: prSuiteError = -2;
#[doc = "\tPlaymod Device Control overview:\n\n\tThis suite is provided so that play modules can control a hardware\n\tdevice during \"Export To Tape.\" The necessary DeviceControlID will only\n\tbe passed down when a transmit is requested. The player must then call\n\tall of the methods in this suite, in the order in which they are\n\tlisted."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPlayModuleDeviceControlSuite {
    #[doc = "\tTell the device to seek to the appropriate location.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Seek:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
    #[doc = "\tTell the device to prepare to record.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Arm:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
    #[doc = "\tTell the device to start recording.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Record:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
    #[doc = "\tTell the device to stop recording. This also cleans up the device control\n\tobject, so it is not available after this call.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Stop:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
}
pub const PrIVProjectionType_kPrIVProjectionType_None: PrIVProjectionType = 0;
pub const PrIVProjectionType_kPrIVProjectionType_Equirectangular: PrIVProjectionType = 1;
#[doc = "\tDefines how the VR image is projected into a 2D frame."]
pub type PrIVProjectionType = ::std::os::raw::c_int;
pub const PrIVFrameLayout_kPrIVFrameLayout_Monoscopic: PrIVFrameLayout = 0;
pub const PrIVFrameLayout_kPrIVFrameLayout_StereoscopicOverUnder: PrIVFrameLayout = 1;
pub const PrIVFrameLayout_kPrIVFrameLayout_StereoscopicSideBySide: PrIVFrameLayout = 2;
#[doc = "\tDefines if the VR image contains a stereoscopic pair, and if so, what type of pair."]
pub type PrIVFrameLayout = ::std::os::raw::c_int;
pub const PrIVStereoscopicEye_kPrIVStereoscopicEye_Left: PrIVStereoscopicEye = 0;
pub const PrIVStereoscopicEye_kPrIVStereoscopicEye_Right: PrIVStereoscopicEye = 1;
pub const PrIVStereoscopicEye_kPrIVStereoscopicEye_Anaglyph: PrIVStereoscopicEye = 2;
#[doc = "\tDefines which eye to view when given a VR image with a stereoscopic pair."]
pub type PrIVStereoscopicEye = ::std::os::raw::c_int;
pub const PrIVAmbisonicsMonitoringType_kPrIVAmbisonicsMonitoringType_Off:
    PrIVAmbisonicsMonitoringType = 0;
pub const PrIVAmbisonicsMonitoringType_kPrIVAmbisonicsMonitoringType_Binaural:
    PrIVAmbisonicsMonitoringType = 1;
#[doc = "\tDefines how ambisonics audio is to be monitored."]
pub type PrIVAmbisonicsMonitoringType = ::std::os::raw::c_int;
pub type kPrIVViewRange = csSDK_int32;
pub type kPrIVViewAngle = f32;
#[doc = " Field of View represents the degrees of view of what the application displays when the desktop's VR View is enabled.\n Captured View represents the degrees of view of what the video frame actually contains."]
pub const kPrIVMinFieldOfView: kPrIVViewRange = 60;
pub const kPrIVMaxFieldOfView: kPrIVViewRange = 180;
#[doc = " These FOV values roughly approximate an average view when compared\n to a HTC Vive or Oculus Rift."]
pub const kPrIVDefaultFieldOfHorizontalView: kPrIVViewRange = 108;
pub const kPrIVDefaultFieldOfVerticalView: kPrIVViewRange = 108;
pub const kPrIVMinCapturedHorizontalView: kPrIVViewRange = 60;
pub const kPrIVMaxCapturedHorizontalView: kPrIVViewRange = 360;
pub const kPrIVDefaultCapturedHorizontalView: kPrIVViewRange = 360;
pub const kPrIVMinCapturedVerticalView: kPrIVViewRange = 60;
pub const kPrIVMaxCapturedVerticalView: kPrIVViewRange = 180;
pub const kPrIVDefaultCapturedVerticalView: kPrIVViewRange = 180;
#[doc = "\tID for a head-related impulse response when monitoring with PrIVAmbisonicsMonitoring_Binaural."]
pub const kPrIVAmbisonicsHRIRLength: usize = 256;
pub type PrIVAmbisonicsHRIR = [prUTF8Char; 256usize];
pub const PrPlaymodReturnValue_playmod_ErrNone: PrPlaymodReturnValue = 0;
pub const PrPlaymodReturnValue_playmod_ErrBadFile: PrPlaymodReturnValue = 1;
pub const PrPlaymodReturnValue_playmod_ErrDriver: PrPlaymodReturnValue = 2;
pub const PrPlaymodReturnValue_playmod_ErrNotPreferred: PrPlaymodReturnValue = 3;
pub const PrPlaymodReturnValue_playmod_BadFormatIndex: PrPlaymodReturnValue = 4;
pub const PrPlaymodReturnValue_playmod_DeclinePlay: PrPlaymodReturnValue = 5;
pub const PrPlaymodReturnValue_playmod_ListWrongType: PrPlaymodReturnValue = 6;
pub const PrPlaymodReturnValue_playmod_ListBadSpeed: PrPlaymodReturnValue = 7;
pub const PrPlaymodReturnValue_playmod_CantAddSegment: PrPlaymodReturnValue = 8;
pub const PrPlaymodReturnValue_playmod_Unsupported: PrPlaymodReturnValue = 9;
pub const PrPlaymodReturnValue_playmod_AudioOverload: PrPlaymodReturnValue = 10;
pub const PrPlaymodReturnValue_playmod_OutOfRange: PrPlaymodReturnValue = 11;
pub const PrPlaymodReturnValue_playmod_CannotRender: PrPlaymodReturnValue = 12;
pub const PrPlaymodReturnValue_playmod_RebuildCutlist: PrPlaymodReturnValue = 13;
pub const PrPlaymodReturnValue_playmod_CannotShiftLayer: PrPlaymodReturnValue = 14;
pub const PrPlaymodReturnValue_playmod_UnsupportedPlaybackSpeed: PrPlaymodReturnValue = 16;
pub const PrPlaymodReturnValue_playmod_BroadcastPrefs: PrPlaymodReturnValue = 17;
pub const PrPlaymodReturnValue_playmod_CannotRecord: PrPlaymodReturnValue = 18;
pub const PrPlaymodReturnValue_playmod_RenderAndPutFrame: PrPlaymodReturnValue = 19;
pub const PrPlaymodReturnValue_pmIsCacheable: PrPlaymodReturnValue = 400;
pub const PrPlaymodReturnValue_playmod_ErrorForceSize: PrPlaymodReturnValue = -1;
#[doc = "\tError Definitions"]
pub type PrPlaymodReturnValue = ::std::os::raw::c_int;
#[doc = "\tType Definitions"]
pub type PrPlayID = csSDK_int32;
pub const pmFieldDisplay_pmFieldDisplay_ShowFirstField: pmFieldDisplay = 0;
pub const pmFieldDisplay_pmFieldDisplay_ShowSecondField: pmFieldDisplay = 1;
pub const pmFieldDisplay_pmFieldDisplay_ShowBothFields: pmFieldDisplay = 2;
pub const pmFieldDisplay_pmFieldDisplay_ForceSize: pmFieldDisplay = -1;
pub type pmFieldDisplay = ::std::os::raw::c_int;
pub const PrPlaymodSelector_playmod_Startup: PrPlaymodSelector = 1;
pub const PrPlaymodSelector_playmod_Shutdown: PrPlaymodSelector = 2;
pub const PrPlaymodSelector_playmod_Open: PrPlaymodSelector = 3;
pub const PrPlaymodSelector_playmod_GetInfo: PrPlaymodSelector = 4;
pub const PrPlaymodSelector_playmod_SetDisp: PrPlaymodSelector = 5;
pub const PrPlaymodSelector_playmod_Update: PrPlaymodSelector = 6;
pub const PrPlaymodSelector_playmod_Stop: PrPlaymodSelector = 10;
pub const PrPlaymodSelector_playmod_PlayIdle: PrPlaymodSelector = 11;
pub const PrPlaymodSelector_playmod_Close: PrPlaymodSelector = 12;
pub const PrPlaymodSelector_playmod_GetIndFormat: PrPlaymodSelector = 14;
pub const PrPlaymodSelector_playmod_NewList: PrPlaymodSelector = 21;
pub const PrPlaymodSelector_playmod_GetFilePrefs: PrPlaymodSelector = 34;
pub const PrPlaymodSelector_playmod_UpdateMarkers: PrPlaymodSelector = 45;
pub const PrPlaymodSelector_playmod_SetFilePrefs: PrPlaymodSelector = 46;
pub const PrPlaymodSelector_playmod_PutFrame: PrPlaymodSelector = 49;
pub const PrPlaymodSelector_playmod_SetQuality: PrPlaymodSelector = 53;
pub const PrPlaymodSelector_playmod_SetPlaybackSpeed: PrPlaymodSelector = 54;
pub const PrPlaymodSelector_playmod_Play: PrPlaymodSelector = 55;
pub const PrPlaymodSelector_playmod_SetPos: PrPlaymodSelector = 56;
pub const PrPlaymodSelector_playmod_GetPos: PrPlaymodSelector = 57;
pub const PrPlaymodSelector_playmod_Step: PrPlaymodSelector = 59;
pub const PrPlaymodSelector_playmod_Preroll: PrPlaymodSelector = 60;
pub const PrPlaymodSelector_playmod_AdornSafeAreas: PrPlaymodSelector = 61;
pub const PrPlaymodSelector_playmod_Activate: PrPlaymodSelector = 62;
pub const PrPlaymodSelector_playmod_EnterScrub: PrPlaymodSelector = 63;
pub const PrPlaymodSelector_playmod_LeaveScrub: PrPlaymodSelector = 64;
pub const PrPlaymodSelector_playmod_SetView: PrPlaymodSelector = 65;
pub const PrPlaymodSelector_playmod_SetDisplayMode: PrPlaymodSelector = 66;
pub const PrPlaymodSelector_playmod_PutFrameRequest: PrPlaymodSelector = 67;
pub const PrPlaymodSelector_playmod_SetVideoDisplayType: PrPlaymodSelector = 69;
pub const PrPlaymodSelector_playmod_DisplayMoving: PrPlaymodSelector = 70;
pub const PrPlaymodSelector_playmod_DisplayChanged: PrPlaymodSelector = 71;
pub const PrPlaymodSelector_playmod_GetAudioInfo: PrPlaymodSelector = 74;
pub const PrPlaymodSelector_playmod_GetAudioChannelInfo: PrPlaymodSelector = 75;
pub const PrPlaymodSelector_playmod_PushPlayerSettings: PrPlaymodSelector = 76;
pub const PrPlaymodSelector_playmod_EnableDynamicPlayback: PrPlaymodSelector = 77;
pub const PrPlaymodSelector_playmod_AllowSetPositionDuringPlayback: PrPlaymodSelector = 78;
pub const PrPlaymodSelector_playmod_VideoSequenceHasChanged: PrPlaymodSelector = 79;
pub const PrPlaymodSelector_playmod_GetRTStatusForTime: PrPlaymodSelector = 80;
pub const PrPlaymodSelector_playmod_SetUseFractionalResolution: PrPlaymodSelector = 81;
pub const PrPlaymodSelector_playmod_SetFractionalResolution: PrPlaymodSelector = 82;
pub const PrPlaymodSelector_playmod_PutTemporaryTimeline: PrPlaymodSelector = 83;
pub const PrPlaymodSelector_playmod_SetDisplayStateProperties: PrPlaymodSelector = 84;
pub const PrPlaymodSelector_playmod_AudioOutputMappingUpdate: PrPlaymodSelector = 85;
pub const PrPlaymodSelector_playmod_SetDest: PrPlaymodSelector = 86;
pub const PrPlaymodSelector_playmod_SetBackgroundColor: PrPlaymodSelector = 87;
pub const PrPlaymodSelector_playmod_GetVRSupported: PrPlaymodSelector = 88;
pub const PrPlaymodSelector_playmod_SetVRConfiguration: PrPlaymodSelector = 89;
pub const PrPlaymodSelector_playmod_GetVRConfiguration: PrPlaymodSelector = 90;
pub const PrPlaymodSelector_playmod_SetVREnabled: PrPlaymodSelector = 91;
pub const PrPlaymodSelector_playmod_GetVREnabled: PrPlaymodSelector = 92;
pub const PrPlaymodSelector_playmod_SetVRView: PrPlaymodSelector = 93;
pub const PrPlaymodSelector_playmod_GetVRView: PrPlaymodSelector = 94;
pub const PrPlaymodSelector_playmod_CalculateVRDisplayDimensions: PrPlaymodSelector = 95;
pub const PrPlaymodSelector_playmod_SetDisplayStateProperties2: PrPlaymodSelector = 96;
pub const PrPlaymodSelector_playmod_SelectorsForceSize: PrPlaymodSelector = -1;
#[doc = "\tSelectors"]
pub type PrPlaymodSelector = ::std::os::raw::c_int;
#[doc = "\tInformation returned from a plugin"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterInfo {
    pub outInterfaceVersion: csSDK_uint32,
    pub outMatchName: PrSDKString,
}
#[doc = "\tA filter instance represents an effect applied to a track item with a fixed set of parameters.\n\tChanged parameters will create a new instance."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterInstance {
    pub piSuites: piSuitesPtr,
    pub inDeviceIndex: csSDK_uint32,
    pub inTimelineID: PrTimelineID,
    pub inNodeID: csSDK_int32,
    pub ioPrivatePluginData: *mut ::std::os::raw::c_void,
    pub outIsRealtime: prBool,
}
#[doc = "\tInformation about a frame render"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterRenderParams {
    pub inClipTime: PrTime,
    pub inSequenceTime: PrTime,
    pub inQuality: PrRenderQuality,
    pub inDownsampleFactorX: f32,
    pub inDownsampleFactorY: f32,
    pub inRenderWidth: csSDK_uint32,
    pub inRenderHeight: csSDK_uint32,
    pub inRenderPARNum: csSDK_uint32,
    pub inRenderPARDen: csSDK_uint32,
    pub inRenderFieldType: prFieldType,
    pub inRenderTicksPerFrame: PrTime,
    pub inRenderField: pmFieldDisplay,
}
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_InputFrame:
    PrGPUFilterFrameDependencyType = 1;
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_Precompute:
    PrGPUFilterFrameDependencyType = 2;
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_FieldSeparation:
    PrGPUFilterFrameDependencyType = 4;
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_TransitionInputFrame:
    PrGPUFilterFrameDependencyType = 8;
#[doc = "\tSpecify dependencies to satisfy a render"]
pub type PrGPUFilterFrameDependencyType = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterFrameDependency {
    pub outDependencyType: PrGPUFilterFrameDependencyType,
    pub outTrackID: csSDK_int32,
    pub outSequenceTime: PrTime,
    pub outPrecomputePixelFormat: PrPixelFormat,
    pub outPrecomputeFrameWidth: csSDK_uint32,
    pub outPrecomputeFrameHeight: csSDK_uint32,
    pub outPrecomputeFramePARNumerator: csSDK_uint32,
    pub outPrecomputeFramePARDenominator: csSDK_uint32,
    pub outPrecomputeFrameFieldType: prFieldType,
    pub outPrecomputeCustomDataSize: csSDK_size_t,
    pub outNeedsFieldSeparation: prBool,
    pub outReadIncomingTransition: prBool,
}
#[doc = "\tGPU Filter callbacks."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilter {
    #[doc = "\tCreates a GPU filter instance representing an effect or transition on a\n\ttrack item. Returning an error from CreateInstance will cause this node\n\tto be rendered in software for the current set of parameters. Separate\n\tinstances may be called concurrently."]
    pub CreateInstance: ::std::option::Option<
        unsafe extern "C" fn(ioInstanceData: *mut PrGPUFilterInstance) -> prSuiteError,
    >,
    pub DisposeInstance: ::std::option::Option<
        unsafe extern "C" fn(ioInstanceData: *mut PrGPUFilterInstance) -> prSuiteError,
    >,
    #[doc = "\tReturn dependency information about a render, or nothing if\n\tonly the current frame is required."]
    pub GetFrameDependencies: ::std::option::Option<
        unsafe extern "C" fn(
            inInstanceData: *mut PrGPUFilterInstance,
            inRenderParams: *const PrGPUFilterRenderParams,
            ioQueryIndex: *mut csSDK_int32,
            outFrameDependencies: *mut PrGPUFilterFrameDependency,
        ) -> prSuiteError,
    >,
    #[doc = "\tPrecompute a result into preallocated uninitialized host (pinned) memory.\n\tWill only be called if PrGPUDependency_Precompute was returned from GetFrameDependencies.\n\tPrecomputation may be called ahead of render time. Results will be\n\tuploaded to the GPU by the host. If outPrecomputePixelFormat is not custom,\n\tframes will be converted to the GPU pixel format."]
    pub Precompute: ::std::option::Option<
        unsafe extern "C" fn(
            inInstanceData: *mut PrGPUFilterInstance,
            inRenderParams: *const PrGPUFilterRenderParams,
            inIndex: csSDK_int32,
            inFrame: PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tRender into an allocated outFrame allocated with PrSDKGPUDeviceSuite or operate\n\tin place. Result must be in the same pixel format as the input. For effects, frame 0\n\twill always be the frame at the current time, other input frames will be in the same order as\n\treturned from GetFrameDependencies. For transitions frame 0 will be the incoming frame and\n\tframe 1 the outgoing frame. Transitions may not have other frame dependencies."]
    pub Render: ::std::option::Option<
        unsafe extern "C" fn(
            inInstanceData: *mut PrGPUFilterInstance,
            inRenderParams: *const PrGPUFilterRenderParams,
            inFrames: *const PPixHand,
            inFrameCount: csSDK_size_t,
            outFrame: *mut PPixHand,
        ) -> prSuiteError,
    >,
}
pub type PrGPUFilterEntry = ::std::option::Option<
    unsafe extern "C" fn(
        inHostInterfaceVersion: csSDK_uint32,
        ioIndex: *mut csSDK_int32,
        inStartup: prBool,
        piSuites: piSuitesPtr,
        outFilter: *mut PrGPUFilter,
        outFilterInfo: *mut PrGPUFilterInfo,
    ) -> prSuiteError,
>;
#[doc = "\tAccess to common GPU image processing algorithms"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct PrSDKGPUImageProcessingSuite {
    #[doc = "\tConvert between formats on the GPU\n\t\tOne of inSrcPixelFormat or inDestPixelFormat must be a host format,\n\tthe other must be either PrPixelFormat_GPU_BGRA_4444_16f or PrPixelFormat_GPU_BGRA_4444_32f"]
    pub PixelFormatConvert: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSrc: *const ::std::os::raw::c_void,
            inSrcRowBytes: csSDK_int32,
            inSrcPixelFormat: PrPixelFormat,
            inDest: *mut ::std::os::raw::c_void,
            inDestRowBytes: csSDK_int32,
            inDestPixelFormat: PrPixelFormat,
            inWidth: csSDK_uint32,
            inHeight: csSDK_uint32,
            inQuality: PrRenderQuality,
        ) -> prSuiteError,
    >,
    #[doc = "\tScale a frame on the GPU\n\t\tinPixelFormat must be PrPixelFormat_GPU_BGRA_4444_16f or PrPixelFormat_GPU_BGRA_4444_32f"]
    pub Scale: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSrc: *const ::std::os::raw::c_void,
            inSrcRowBytes: csSDK_int32,
            inSrcWidth: csSDK_uint32,
            inSrcHeight: csSDK_uint32,
            inDest: *mut ::std::os::raw::c_void,
            inDestRowBytes: csSDK_int32,
            inDestWidth: csSDK_uint32,
            inDestHeight: csSDK_uint32,
            inPixelFormat: PrPixelFormat,
            inScaleX: f32,
            inScaleY: f32,
            inQuality: PrRenderQuality,
        ) -> prSuiteError,
    >,
    #[doc = "\tGaussian blur on the GPU\n\t\tinPixelFormat must be PrPixelFormat_GPU_BGRA_4444_16f or PrPixelFormat_GPU_BGRA_4444_32f"]
    pub GaussianBlur: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSrc: *const ::std::os::raw::c_void,
            inSrcRowBytes: csSDK_int32,
            inSrcWidth: csSDK_uint32,
            inSrcHeight: csSDK_uint32,
            inDest: *mut ::std::os::raw::c_void,
            inDestRowBytes: csSDK_int32,
            inDestWidth: csSDK_uint32,
            inDestHeight: csSDK_uint32,
            inPixelFormat: PrPixelFormat,
            inSigmaX: f32,
            inSigmaY: f32,
            inRepeatEdgePixels: prBool,
            inBlurHorizontally: prBool,
            inBlurVertically: prBool,
            inQuality: PrRenderQuality,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKMemoryManagerSuiteV1 {
    #[doc = "\tSet the memory reserve size in bytes for the plugin with the specified ID.\n\n\t@param\tinPluginID\t\t\tThe ID of the plugin.\n\t@param\tinSize\t\t\t\tThe size in bytes to reserve."]
    pub ReserveMemory: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_uint32) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKMemoryManagerSuiteV2 {
    #[doc = "\tSet the memory reserve size in bytes for the plugin with the specified ID.\n\n\t@param\tinPluginID\t\t\tThe ID of the plugin.\n\t@param\tinSize\t\t\t\tThe size in bytes to reserve."]
    pub ReserveMemory: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_uint32) -> prSuiteError,
    >,
    pub NewPtrClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub NewPtr: ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub GetPtrSize: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr) -> csSDK_uint32>,
    pub SetPtrSize:
        ::std::option::Option<unsafe extern "C" fn(p: *mut PrMemoryPtr, newSize: csSDK_uint32)>,
    pub NewHandle:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub NewHandleClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub PrDisposePtr: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr)>,
    pub DisposeHandle: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
    pub SetHandleSize: ::std::option::Option<
        unsafe extern "C" fn(h: PrMemoryHandle, newSize: csSDK_uint32) -> ::std::os::raw::c_short,
    >,
    pub GetHandleSize:
        ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle) -> csSDK_uint32>,
    pub HUnlock: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
    pub HLock: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
}
pub type PrSDKMemoryManagerSuite_PurgeMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(inPurgeMemoryData: *mut ::std::os::raw::c_void, inMemoryID: csSDK_uint32),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKMemoryManagerSuite {
    #[doc = "\tSet the memory reserve size in bytes for the plugin with the specified ID.\n\n\t@param\tinPluginID\t\t\tThe ID of the plugin.\n\t@param\tinSize\t\t\t\tThe size in bytes to reserve."]
    pub ReserveMemory: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_uint32) -> prSuiteError,
    >,
    #[doc = "\tGet the current size of the media cache in this process.\n\n\t@param\toutMemoryManagerSize\tThe size of the memory manager in bytes."]
    pub GetMemoryManagerSize: ::std::option::Option<
        unsafe extern "C" fn(outMemoryManagerSize: *mut csSDK_uint64) -> prSuiteError,
    >,
    #[doc = "\tAdd a block of memory to management. This block should not be something entered\n\tin any of the suite cache, and it must be purgeable. The purge function you pass in\n\tmay be called on any thread.\n\n\t@param\tinSize\t\t\t\tThe size in bytes of the item in question.\n\t@param\tinPurgeFunction\t\tThe function pointer that will be called to purge the item.\n\t@param\tinPurgeMemoryData\tThe data object passed back in the purge callback.\n\t@param\toutID\t\t\t\tThe id the host will use for this item."]
    pub AddBlock: ::std::option::Option<
        unsafe extern "C" fn(
            inSize: csSDK_size_t,
            inPurgeFunction: PrSDKMemoryManagerSuite_PurgeMemoryFunction,
            inPurgeMemoryData: *mut ::std::os::raw::c_void,
            outID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tEach time you use a block of memory, you should call this function. This pushes its\n\tpriority up in the cache, making a purge less likely.\n\n\t@param\tinID\t\t\t\tThe id of the block to touch."]
    pub TouchBlock: ::std::option::Option<unsafe extern "C" fn(inID: csSDK_uint32) -> prSuiteError>,
    #[doc = "\tYou can manually expire an item from the cache with this function. Note that the purge function\n\ton the item will not be called.\n\n\t@param\tinID\t\t\t\tThe id of the block to touch."]
    pub RemoveBlock:
        ::std::option::Option<unsafe extern "C" fn(inID: csSDK_uint32) -> prSuiteError>,
    pub NewPtrClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub NewPtr: ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub GetPtrSize: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr) -> csSDK_uint32>,
    pub SetPtrSize:
        ::std::option::Option<unsafe extern "C" fn(p: *mut PrMemoryPtr, newSize: csSDK_uint32)>,
    pub NewHandle:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub NewHandleClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub PrDisposePtr: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr)>,
    pub DisposeHandle: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
    pub SetHandleSize: ::std::option::Option<
        unsafe extern "C" fn(h: PrMemoryHandle, newSize: csSDK_uint32) -> ::std::os::raw::c_short,
    >,
    pub GetHandleSize:
        ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle) -> csSDK_uint32>,
    pub AdjustReservedMemorySize: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_int64) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPixelFormatSuite {
    #[doc = "\tRetrieves the minimum i.e. \"black\" value for a give pixel type.\n\n\t[NOTE]\tpixel types like YUY2, YUYV actually contain a group of two pixels to specify a color\n\t\t\tcompletely, so the data size returned in this case will be 4 bytes (rather than 2)\n\n\t@param\t\tpixelFormat\t\t\t\tthe Premiere pixel format whose black level you want\n\t@param\t\tpixelData\t\t\t\ta void pointer to data large enough to hold the pixel value (see note above)\n\n\t@returns\tsuiteError_NoError : successful retreival of black value\n\t@returns\tsuiteError_Fail :"]
    pub GetBlackForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    #[doc = "\tRetrieves the maximum i.e. \"white\" value for a give pixel type.\n\n\t[NOTE]\tpixel types like YUY2, YUYV actually contain a group of two pixels to specify a color\n\t\t\tcompletely, so the data size returned in this case will be 4 bytes (rather than 2)\n\n\t@param\t\tpixelFormat\t\t\t\tthe Premiere pixel format whose white level you want\n\t@param\t\tpixelData\t\t\t\ta void pointer to data large enough to hold the pixel value (see note above)\n\n\t@returns\tsuiteError_NoError : successful retreival of white value\n\t@returns\tsuiteError_Fail :"]
    pub GetWhiteForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    #[doc = "\tConverts an alpha, red, green, blue specification into a pixel value for a give pixel type.\n\n\t[NOTE]\tpixel types like YUY2, YUYV actually contain a group of two pixels to specify a color\n\t\t\tcompletely, so the data size returned in this case will be 4 bytes (rather than 2)\n\n\t@param\t\tpixelFormat\t\t\t\tthe Premiere pixel format whose white level you want\n\t@param\t\talpha\t\t\t\t\talpha value (0.0 - 1.0)\n\t@param\t\tred\t\t\t\t\t\tred value (0.0 - 1.0)\n\t@param\t\tgreen\t\t\t\t\tgreen value (0.0 - 1.0)\n\t@param\t\tblue\t\t\t\t\tblue value (0.0 - 1.0)\n\t@param\t\tpixelData\t\t\t\ta void pointer to data large enough to hold the pixel value (see note above)\n\n\t@returns\tsuiteError_NoError : successful conversion of color value\n\t@returns\tsuiteError_Fail :"]
    pub ConvertColorToPixelFormattedData: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            alpha: f32,
            red: f32,
            green: f32,
            blue: f32,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
}
pub const PrPPixBufferAccess_PrPPixBufferAccess_ReadOnly: PrPPixBufferAccess = 0;
pub const PrPPixBufferAccess_PrPPixBufferAccess_WriteOnly: PrPPixBufferAccess = 1;
pub const PrPPixBufferAccess_PrPPixBufferAccess_ReadWrite: PrPPixBufferAccess = 2;
pub const PrPPixBufferAccess_PrPPixBufferAccess_ForceEnumSize: PrPPixBufferAccess = -1;
pub type PrPPixBufferAccess = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixSuite {
    #[doc = "\tThis will free this ppix. The ppix is no longer valid after this function is called.\n\n\t@param\tinPPixHand\t\t\t\tThe ppix handle you want to dispose."]
    pub Dispose: ::std::option::Option<unsafe extern "C" fn(inPPixHand: PPixHand) -> prSuiteError>,
    #[doc = "\tThis will return a pointer to the pixel buffer.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\tinRequestedAccess\tRequested pixel access. Most PPixs do not support write access modes.\n\t@param\toutPixelAddress\t\tThe output pixel buffer address. May be NULL if the requested pixel access is not supported."]
    pub GetPixels: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            outPixelAddress: *mut *mut ::std::os::raw::c_char,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the bounding rect.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutBoundingRect\t\tThe address of a bounding rect to be filled in."]
    pub GetBounds: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, inoutBoundingRect: *mut prRect) -> prSuiteError,
    >,
    #[doc = "\tThis will return the row bytes of the ppix.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutRowBytes\t\t\tReturns how many bytes must be added to the pixel buffer address to get to the next line.\n\t\t\t\t\t\t\t\tMay be negative."]
    pub GetRowBytes: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outRowBytes: *mut csSDK_int32) -> prSuiteError,
    >,
    #[doc = "\tThis will return the pixel aspect ratio of this ppix.\n\n\t@param\tinPPixHand\t\t\t\t\t\tThe ppix handle you want to operate on.\n\t@param\toutPixelAspectRatioNumerator\tReturns the numerator of the pixel aspect ratio.\n\t@param\toutPixelAspectRatioDenominator\tReturns the denominator of the pixel aspect ratio."]
    pub GetPixelAspectRatio: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outPixelAspectRatioNumerator: *mut csSDK_uint32,
            outPixelAspectRatioDenominator: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the pixel format of this ppix.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutPixelFormat\t\tReturns the pixel format of this ppix."]
    pub GetPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outPixelFormat: *mut PrPixelFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the unique key for this ppix.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutKeyBuffer\t\tReturns the pixel format of this ppix.\n\n\t[TODO] Fill in returned error codes.\n\t@returns Error if the buffer size is too small (call GetUniqueKeySize() to get the correct size).\n\t@returns Error if the key is not available.\n\t@returns Success if the key data was filled in."]
    pub GetUniqueKey: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            inoutKeyBuffer: *mut ::std::os::raw::c_uchar,
            inKeyBufferSize: usize,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the unique key size.\n\tThis will not change for the entire run of the application.\n\n\t@param\toutKeyBufferSize\tReturns the size of the ppix unique key."]
    pub GetUniqueKeySize:
        ::std::option::Option<unsafe extern "C" fn(outKeyBufferSize: *mut usize) -> prSuiteError>,
    #[doc = "\tThis will return the render time for this ppix.\n\n\t@param\tinPPixHand\t\t\t\tThe ppix handle you want to operate on.\n\t@param\toutRenderMilliseconds\tReturns the render time in milliseconds. If the frame was cached, this time will be 0."]
    pub GetRenderTime: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outRenderMilliseconds: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPix2Suite {
    #[doc = "\tThis will return the total size of the ppix in bytes.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutSize\t\t\t\tThe size of the ppix in bytes."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outSize: *mut usize) -> prSuiteError,
    >,
    #[doc = "\t[Added in CS4]\n\tThis will return the planar buffers and rowbytes for a PPixHand\n\tif the contained pixels are in a planar format, such as\n\tPrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601\n\tPrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601\n\tPrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709\n\tPrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\tinRequestedAccess\tWill return an error if the source is read-only and the request is for write or read/write.\n\n\t@param\tout_xxx_PixelAddress\tThe output (Y, U, or V) pixel buffer address. May be NULL if the requested access is not supported.\n\t@param\tout_xxx_RowBytes\t\tReturns how many bytes must be added to the pixel buffer address to get to the next line.\n\t\t\t\t\t\t\t\t\tMay be negative."]
    pub GetYUV420PlanarBuffers: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            out_Y_PixelAddress: *mut *mut ::std::os::raw::c_char,
            out_Y_RowBytes: *mut csSDK_uint32,
            out_U_PixelAddress: *mut *mut ::std::os::raw::c_char,
            out_U_RowBytes: *mut csSDK_uint32,
            out_V_PixelAddress: *mut *mut ::std::os::raw::c_char,
            out_V_RowBytes: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub GetOrigin: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outOriginX: *mut csSDK_int32,
            outOriginY: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    pub GetFieldOrder: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outFieldType: *mut prFieldType) -> prSuiteError,
    >,
}
#[doc = "\tThis struct defines a specific frame format that is being requested\n\tfromt the importer. Any member can be 0, which means that any value\n\tis an acceptable match. For instance, the host might ask for a specific\n\twidth and height, but pass 0 as the pixel format, meaning it can accept\n\tany pixel format."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct imFrameFormat {
    pub inFrameWidth: csSDK_int32,
    pub inFrameHeight: csSDK_int32,
    pub inPixelFormat: PrPixelFormat,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCacheSuite {
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length"]
    pub AddFrameToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length"]
    pub GetFrameFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the raw cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinPPixHand\t\t\tThe raw ppix handle you want to add.\n\t@param\tinKey\t\t\t\tThe key to use for this raw ppix. If an entry with this key already\n\t\t\t\t\t\t\t\texists, this call will fail."]
    pub AddRawPPixToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inPPixHand: PPixHand,
            inKey: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinKey\t\t\t\tThe key to identify this raw ppix.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame."]
    pub GetRawPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inKey: csSDK_int32,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function allows you to cache a PPix using a GUID as an identifier.\n\n\t@param\tinPPixIdentifier\tThe ID of the PPix, used to identify this particular set of pixels.\n\t\t\t\t\t\t\t\tThe GUID can be anything, but must be unique.\n\t@param\tinPPix\t\t\t\tThe Pixels to put in the cache. If a frame with this id is already in the cache,\n\t\t\t\t\t\t\t\tthen this PPix will be ignored. You still have ownership over the PPix.\n\t\t\t\t\t\t\t\tYou may want to get the PPix from the cache after this, in case your frame is redundant."]
    pub AddNamedPPixToCache: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID, inPPix: PPixHand) -> prSuiteError,
    >,
    #[doc = "\tThis function retrieves a named PPix from the cache.\n\n\t@param\tinPPixIdentifier\tThe ID of the PPix.\n\t@param\toutPPixHand\t\t\tThe PPix, if it's available. If it's not in the cache, this will be NULL.\n\t\t\t\t\t\t\t\tYou are responsible for calling PPixDispose on this PPix, like any other."]
    pub GetNamedPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixIdentifier: *const prPluginID,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with that identifier is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for call the Unregister function - if you don't then this is the\n\tsame as a memory leak of a PPix.\n\n\t@param\tinPPixIdentifier\tThe ID of the PPix you want held in the cache."]
    pub RegisterDependencyOnNamedPPix: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID) -> prSuiteError,
    >,
    #[doc = "\tThis function unregisters a dependency on a named PPix. This must be called for every successful call of\n\tRegisterDependencyOnNamedPPix\n\n\t@param inPPixIdentifier\t\tThe ID of the PPix you no longer need in the cache."]
    pub UnregisterDependencyOnNamedPPix: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID) -> prSuiteError,
    >,
    #[doc = "  This function attempts to flush a frame from the cache. If the frame has a registered dependency, then the\n  frame will remain available until the dependency count hits zero.\n\n\t@param inPPixIdentifier\t\tThe ID of the PPix you want forcibly removed from the cache."]
    pub ExpireNamedPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID) -> prSuiteError,
    >,
    #[doc = "  This function attempts to flush all ppixes from the cache."]
    pub ExpireAllPPixesFromCache: ::std::option::Option<unsafe extern "C" fn() -> prSuiteError>,
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub AddFrameToCacheWithColorProfile: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub GetFrameFromCacheWithColorProfile: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub AddFrameToCacheWithColorProfile2: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub GetFrameFromCacheWithColorProfile2: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinQuality\t\t\tThe quality level with which to render the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinPrColorSpaceID\tcolor space for the frame to be cached; this is an opaque token passed to the importer by the host that importer is expected to use in color management APIs"]
    pub AddFrameToCacheWithColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inPrColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n @param\tinNumFormats\t\tThe number of frame formats\n\t@param\tinFormats\t\t\tThe array of frame formats\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinQuality\t\t\tThe quality level with which to render the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinPrColorSpaceID\tcolor space to be used as part of identifier to retrieve a frame from cache; this is an opaque token passed to the importer by the host that importer is expected to use in color management APIs"]
    pub GetFrameFromCacheWithColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inPrColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length"]
    pub RegisterDependencyOnFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub RegisterDependencyOnFrameWithColorProfile: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub RegisterDependencyOnFrameWithColorProfile2: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            inQuality: PrRenderQuality,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n \t@param\tinNumFormats\t\tThe number of frame formats\n\t@param\tinFormats\t\t\tThe array of frame formats\n\t@param\tinQuality\t\t\tThe quality level with which to render the frame\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinPrColorSpaceID\tcolor space to be used as part of identifier to retrieve a frame from cache; this is an opaque token passed to the importer by the host that importer is expected to use in color management APIs"]
    pub RegisterDependencyOnFrameWithColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            inQuality: PrRenderQuality,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inPrColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCacheSuite1 {
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix."]
    pub AddFrameToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame."]
    pub GetFrameFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the raw cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinPPixHand\t\t\tThe raw ppix handle you want to add.\n\t@param\tinKey\t\t\t\tThe key to use for this raw ppix. If an entry with this key already\n\t\t\t\t\t\t\t\texists, this call will fail."]
    pub AddRawPPixToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inPPixHand: PPixHand,
            inKey: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinKey\t\t\t\tThe key to identify this raw ppix.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame."]
    pub GetRawPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inKey: csSDK_int32,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCreator2Suite {
    #[doc = "\tThis will create a new ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinUseFields\t\t\t\t\t\tIf true, the ppix is a field.\n\t@param\tinFieldNumber\t\t\t\t\tIf inUseFields is true, this specifies first field (0) or second (1)\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix."]
    pub CreatePPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inUseFields: bool,
            inFieldNumber: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new raw ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinSize\t\t\t\t\t\t\tThe size of the ppix in bytes.\n\t@param\tinAlignment\t\t\t\t\t\tThe alignment of the beginning of the ppix in bytes."]
    pub CreateRawPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inSize: ::std::os::raw::c_int,
            inAlignment: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix in a custom pixel format.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinDataBufferSize\t\t\t\tThe number of bytes requested, not including the header."]
    pub CreateCustomPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inDataBufferSize: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix properly aligned for reading from disk.\n\n\t@param\toutPPixHand\t\t\t\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinPixelFormat\t\t\t\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinMemoryAlignment\t\t\t\t\t\t\tThe alignment of memory required for the start of the first sector.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIf this value is zero, then we will align to the sector size.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis value must be a multiple of the pixel size or bad things will happen.\n\t@param\tinSectorSize\t\t\t\t\t\t\t\tThe size of a sector on disk. The required amount of memory will be padded\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tup to a multiple of the sector size. If this is zero, then there will be no padding.\n\t@param\tinOffsetToPixelDataFromFirstSectorStart\t\tThe number of bytes between the start of the first sector and the start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tof the pixel data. The resulting pixel start location must be aligned to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe pixel size."]
    pub CreateDiskAlignedPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inMemoryAlignment: ::std::os::raw::c_int,
            inSectorSize: ::std::os::raw::c_int,
            inOffsetToPixelDataFromFirstSectorStart: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinUseFields\t\t\t\t\t\tIf true, the ppix is a field.\n\t@param\tinFieldNumber\t\t\t\t\tIf inUseFields is true, this specifies first field (0) or second (1)\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param \tinColorSpaceID\t\t\t\t\topaque color space identifier; new video frame will be tagged with this color space"]
    pub CreateColorManagedPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inUseFields: bool,
            inFieldNumber: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix in a custom pixel format.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinDataBufferSize\t\t\t\tThe number of bytes requested, not including the header.\n\t@param \tinColorSpaceID\t\t\t\t\topaque color space identifier; new video frame will be tagged with this color space"]
    pub CreateColorManagedCustomPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inDataBufferSize: ::std::os::raw::c_int,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix properly aligned for reading from disk.\n\n\t@param\toutPPixHand\t\t\t\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinPixelFormat\t\t\t\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinMemoryAlignment\t\t\t\t\t\t\tThe alignment of memory required for the start of the first sector.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIf this value is zero, then we will align to the sector size.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis value must be a multiple of the pixel size or bad things will happen.\n\t@param\tinSectorSize\t\t\t\t\t\t\t\tThe size of a sector on disk. The required amount of memory will be padded\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tup to a multiple of the sector size. If this is zero, then there will be no padding.\n\t@param\tinOffsetToPixelDataFromFirstSectorStart\t\tThe number of bytes between the start of the first sector and the start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tof the pixel data. The resulting pixel start location must be aligned to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe pixel size.\n\t@param \tinColorSpaceID\t\t\t\t\t\t\t\topaque color space identifier; new video frame will be tagged with this color space"]
    pub CreateColorManagedDiskAlignedPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inMemoryAlignment: ::std::os::raw::c_int,
            inSectorSize: ::std::os::raw::c_int,
            inOffsetToPixelDataFromFirstSectorStart: ::std::os::raw::c_int,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCreatorSuite {
    #[doc = "\tThis will create a new ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix."]
    pub CreatePPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inBoundingRect: *const prRect,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will clone an existing ppix. It will ref-count the ppix if only read-access is requested and\n\t\tthe ppix to copy from is read-only as well, otherwise it will create a new one and copy.\n\n\t@param\tinPPixToClone\t\t\t\t\tThe ppix to clone from.\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access on the new ppix. (Only PrPPixBufferAccess_ReadOnly is allowed right now)."]
    pub ClonePPix: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixToClone: PPixHand,
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSceneTimebaseRec {
    pub scale: csSDK_uint32,
    pub sampleSize: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSceneRecord {
    pub startTime: csSDK_int32,
    pub duration: csSDK_int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrSceneMetaDataRec {
    pub timeBase: PrSceneTimebaseRec,
    pub scenes: [PrSceneRecord; 1usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKSequenceInfoSuite {
    #[doc = "\tGet the video frame size of the sequence.\n\n\t@param\tinTimelineID\tthe timeline instance data\n\t@param\toutFrameRect\ton return, the size of the sequence video frame."]
    pub GetFrameRect: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outFrameRect: *mut prRect) -> prSuiteError,
    >,
    #[doc = "\tGet the aspect ratio of the sequence.\n\n\t@param\tinTimelineID\tthe timeline instance data\n\t@param\toutNumerator\ton return, the aspect ratio numerator.\n\t@param\toutDenominator\ton return, the aspect ratio denominator."]
    pub GetPixelAspectRatio: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outNumerator: *mut csSDK_uint32,
            outDenominator: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the framerate of the sequence.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutTicksPerFrame\tthe framerate in ticks."]
    pub GetFrameRate: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outTicksPerFrame: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the field type of the sequence.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutFieldType\t\tthe field type."]
    pub GetFieldType: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outFieldType: *mut prFieldType,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the zero point of the sequence.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutTicksPerFrame\tstart time of the sequence."]
    pub GetZeroPoint: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outTime: *mut PrTime) -> prSuiteError,
    >,
    #[doc = "\tReturns if the sequence timecode is drop or non drop.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutDropFrame\t\tif the sequence timecode is dropframe"]
    pub GetTimecodeDropFrame: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outDropFrame: *mut prBool) -> prSuiteError,
    >,
    #[doc = "\tReturns if the sequence has the proxy flag set.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutProxyFlag\t\tif the sequence is in proxy mode"]
    pub GetProxyFlag: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outDropFrame: *mut prBool) -> prSuiteError,
    >,
    #[doc = "\tReturns the VR Video settings of the specified sequence.\n\n\t@param\tinTimelineID\t\t\t\tThe timeline instance data.\n\t@param\toutProjectionType\t\t\tThe type of projection the specified sequence is using.\n\t@param\toutFrameLayout\t\t\t\tThe type of frame layout the specified sequence is using.\n\t@param\toutHorizontalCapturedView\tHow many degrees of horizontal view is captured in the video stream (up to 360).\n\t@param\toutVerticalCapturedView\t\tHow many degrees of vertical view is captured in the video stream (up to 180)."]
    pub GetImmersiveVideoVRConfiguration: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outProjectionType: *mut PrIVProjectionType,
            outFrameLayout: *mut PrIVFrameLayout,
            outHorizontalCapturedView: *mut csSDK_uint32,
            outVerticalCapturedView: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = " Returns the identifier of the sequence working color space\n\n\t@param\tinTimelineID\t\t\t\tThe timeline instance data.\n\t@param\toutPrWorkingColorSpaceID\tPrSDKColorSpaceID with working color space identifier\n"]
    pub GetWorkingColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outPrWorkingColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the HDR graphics white luminance value of the sequence in nits.\n\n\t@param\tinTimelineID\tthe timeline instance data\n\t@param\toutGraphicsWhiteLuminance\ton return, HDR graphics white luminance value of the sequence in nits."]
    pub GetGraphicsWhiteLuminance: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outGraphicsWhiteLuminance: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
}
pub type PrSDKStreamLabel = *const ::std::os::raw::c_char;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_FrameInfoRec {
    pub repeatCount: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_GetFrameReturnRec {
    pub asyncCompletionData: *mut ::std::os::raw::c_void,
    pub returnVal: csSDK_int32,
    pub repeatCount: csSDK_int32,
    pub onMarker: csSDK_int32,
    pub outFrame: PPixHand,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_ParamsRec {
    pub inRequestedPixelFormatArray: *const PrPixelFormat,
    pub inRequestedPixelFormatArrayCount: csSDK_int32,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
    pub inPixelAspectRatioNumerator: csSDK_int32,
    pub inPixelAspectRatioDenominator: csSDK_int32,
    pub inRenderQuality: PrRenderQuality,
    pub inFieldType: prFieldType,
    pub inDeinterlace: csSDK_int32,
    pub inDeinterlaceQuality: PrRenderQuality,
    pub inCompositeOnBlack: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_ParamsRecExt {
    pub inRequestedPixelFormatArray: *const PrPixelFormat,
    pub inRequestedPixelFormatArrayCount: csSDK_int32,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
    pub inPixelAspectRatioNumerator: csSDK_int32,
    pub inPixelAspectRatioDenominator: csSDK_int32,
    pub inRenderQuality: PrRenderQuality,
    pub inFieldType: prFieldType,
    pub inDeinterlace: csSDK_int32,
    pub inDeinterlaceQuality: PrRenderQuality,
    pub inCompositeOnBlack: csSDK_int32,
    pub inPrSDKColorSpaceID: PrSDKColorSpaceID,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_ParamsRecExt2 {
    pub inRequestedPixelFormatArray: *const PrPixelFormat,
    pub inRequestedPixelFormatArrayCount: csSDK_int32,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
    pub inPixelAspectRatioNumerator: csSDK_int32,
    pub inPixelAspectRatioDenominator: csSDK_int32,
    pub inRenderQuality: PrRenderQuality,
    pub inFieldType: prFieldType,
    pub inDeinterlace: csSDK_int32,
    pub inDeinterlaceQuality: PrRenderQuality,
    pub inCompositeOnBlack: csSDK_int32,
    pub inPrSDKColorSpaceID: PrSDKColorSpaceID,
    pub inPrSDKLUTID: PrSDKLUTID,
}
pub type PrSDKSequenceAsyncRenderCompletionProc = ::std::option::Option<
    unsafe extern "C" fn(
        inVideoRenderID: csSDK_uint32,
        inCallbackRef: *mut ::std::os::raw::c_void,
        inTime: PrTime,
        inRenderedFrame: PPixHand,
        inGetFrameReturn: *mut SequenceRender_GetFrameReturnRec,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKSequenceRenderSuite {
    pub MakeVideoRenderer: ::std::option::Option<
        unsafe extern "C" fn(
            pluginID: csSDK_uint32,
            outVideoRenderID: *mut csSDK_uint32,
            inFrameRate: PrTime,
        ) -> prSuiteError,
    >,
    pub ReleaseVideoRenderer: ::std::option::Option<
        unsafe extern "C" fn(pluginID: csSDK_uint32, inVideoRenderID: csSDK_uint32) -> prSuiteError,
    >,
    pub RenderVideoFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParams: *mut SequenceRender_ParamsRec,
            inCacheFlags: PrRenderCacheType,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub QueueAsyncVideoFrameRender: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outRequestID: *mut csSDK_uint32,
            inRenderParams: *mut SequenceRender_ParamsRec,
            inCacheFlags: PrRenderCacheType,
            inAsyncCompletionData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub SetAsyncRenderCompletionProc: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            asyncGetFrameCallback: PrSDKSequenceAsyncRenderCompletionProc,
            callbackRef: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub GetFrameInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outFrameInfo: *mut SequenceRender_FrameInfoRec,
        ) -> prSuiteError,
    >,
    #[doc = "\tPre-fetches the media needed to render this frame.\n\tThis is a hint to the importers to begin reading media needed to render this video frame.\n\n\t@param\tinFrame\t\t\t\t\t\t\t\tThe video frame number."]
    pub PrefetchMedia: ::std::option::Option<
        unsafe extern "C" fn(inVideoRenderID: csSDK_uint32, inFrame: PrTime) -> prSuiteError,
    >,
    #[doc = "\tPre-fetches the media needed to render this frame, using all of the parameters used to render the frame.\n\tThis is a hint to the importers to begin reading media needed to render this video frame.\n\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\n\t@param\tinRequestedPixelFormatArray\t\t\tAn array of PrPixelFormats that list your format preferences in order.\n\t\t\t\t\t\t\t\t\t\t\t\tThis list must end with PrPixelFormat_BGRA_4444_8u.\n\t@param\tinRequestedPixelFormatArrayCount\tNumber of formats in the format array\n\t@param\tinFrameRect\t\t\t\t\t\t\tVideo frame size\n\t@param\tinPixelAspectRatioNumerator\t\t\tThe numerator for the pixel aspect ratio.\n\t@param\tinPixelAspectRatioDenominator\t\tThe denominator for the pixel aspect ratio.\n\t@param\tinRenderQuality\t\t\t\t\t\tThe render quality of this frame."]
    pub PrefetchMediaWithRenderParameters: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParams: *mut SequenceRender_ParamsRec,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will cancel all media pre-fetches that are still outstanding."]
    pub CancelAllOutstandingMediaPrefetches:
        ::std::option::Option<unsafe extern "C" fn(inVideoRenderID: csSDK_uint32) -> prSuiteError>,
    #[doc = "\tIs all the prefetched media ready?"]
    pub IsPrefetchedMediaReady: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outMediaReady: *mut prBool,
        ) -> prSuiteError,
    >,
    pub MakeVideoRendererForTimeline: ::std::option::Option<
        unsafe extern "C" fn(
            inTimeline: PrTimelineID,
            outVideoRendererID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub MakeVideoRendererForTimelineWithFrameRate: ::std::option::Option<
        unsafe extern "C" fn(
            inTimeline: PrTimelineID,
            inFrameRate: PrTime,
            outVideoRendererID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub ReleaseVideoRendererForTimeline: ::std::option::Option<
        unsafe extern "C" fn(inVideoRendererID: csSDK_uint32) -> prSuiteError,
    >,
    pub RenderVideoFrameAndConformToPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParams: *mut SequenceRender_ParamsRec,
            inCacheFlags: PrRenderCacheType,
            inConformToFormat: PrPixelFormat,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub MakeVideoRendererForTimelineWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimeline: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoRendererID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
            inCacheFlags: PrRenderCacheType,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub QueueAsyncColorManagedVideoFrameRender: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outRequestID: *mut csSDK_uint32,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
            inCacheFlags: PrRenderCacheType,
            inAsyncCompletionData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PrefetchColorManagedMedia: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inFrame: PrTime,
            inPrSDKColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    pub PrefetchColorManagedMediaWithRenderParameters: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrameAndConformToPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
            inCacheFlags: PrRenderCacheType,
            inConformToFormat: PrPixelFormat,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrame2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
            inCacheFlags: PrRenderCacheType,
            outGetFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub QueueAsyncColorManagedVideoFrameRender2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outRequestID: *mut csSDK_uint32,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
            inCacheFlags: PrRenderCacheType,
            inAsyncCompletionData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PrefetchColorManagedMediaWithRenderParameters2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrameAndConformToPixelFormat2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
            inCacheFlags: PrRenderCacheType,
            inConformToFormat: PrPixelFormat,
            outGetFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrClipSegmentInfo {
    pub mClipID: csSDK_int32,
    pub mSegmentStartTime: csSDK_int64,
    pub mSegmentEndTime: csSDK_int64,
    pub mSegmentOffset: csSDK_int64,
    pub mClipStartTime: csSDK_int64,
    pub mClipEndTime: csSDK_int64,
    pub mClipPath: PrSDKString,
    pub mMediaStartTime: csSDK_int64,
    pub mMediaEndTime: csSDK_int64,
}
pub type SegmentInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(
        inCallbackData: *mut ::std::os::raw::c_void,
        inClipSegmentInfo: *mut PrClipSegmentInfo,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKSmartRenderingSuite {
    pub BuildSmartRenderSegmentList: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
        ) -> prSuiteError,
    >,
    pub BuildSmartRenderSegmentListNoPreviewFiles: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
        ) -> prSuiteError,
    >,
    pub BuildAncillaryDataSegmentMap: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inVideoSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
        ) -> prSuiteError,
    >,
    pub BuildColorManagedSmartRenderSegmentList: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    pub BuildColorManagedSmartRenderSegmentListNoPreviewFiles: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKStringSuite {
    #[doc = "\tThis will dispose of an SDKString. It is OK to pass in an empty string.\n\n\t@param\tinSDKString\t\t\t\tthe string to dispose of\n\n\t@return suiteError_StringNotFound\tthis string has not been allocated, or may have already been disposed\n\t@return suiteError_InvalidParms\t\tone of the params is invalid"]
    pub DisposeString: ::std::option::Option<
        unsafe extern "C" fn(inSDKString: *const PrSDKString) -> prSuiteError,
    >,
    #[doc = "\tThis will allocate an SDKString from a passed in null terminated string.\n\n\t@param\tinUTF8String\t\t\tnull terminated UTF8 string to copy into the SDK string\n\t@param\tioSDKString\t\t\t\tthis passed in SDK string will receive the new allocated string\n\t\t\t\t\t\t\t\t\t\t- you must dispose of this sdk string\n\n\t@return suiteError_StringNotFound\tthis string has not been allocated, or may have already been disposed\n\t@return suiteError_InvalidParms\t\tone of the params is invalid"]
    pub AllocateFromUTF8: ::std::option::Option<
        unsafe extern "C" fn(
            inUTF8String: *const prUTF8Char,
            outSDKString: *mut PrSDKString,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will copy an SDKString into a UTF8 null terminated string if ioUTF8StringBufferByteCount reports enough bytes in\n\t\tthe string buffer to copy. If there are not enough bytes - suiteError_StringBufferTooSmall will be returned\n\t\tand ioUTF8StringBufferByteCount will contain the number of bytes needed to hold the string.\n\n\t@param\toutUTF8StringBuffer\t\t\t\t\tBuffer where UTF8 string will be stored\n\t@param\tioUTF8StringBufferSizeInElements\tPass in the size, in elements, of outUTF8StringStorage. Returns the number of elements copied.  Includes terminating 0.\n\n\t@return suiteError_InvalidParms\t\t\tOne of the params is invalid\n\t@return suiteError_StringBufferTooSmall\tThe passed in string buffer is too small. ioUTF8StringBufferByteCount will contain the number of bytes needed to copy this string.\n\t@return suiteError_NoError\t\t\t\tThe string has been copied. ioUTF8StringBufferByteCount contains the number of bytes copied."]
    pub CopyToUTF8String: ::std::option::Option<
        unsafe extern "C" fn(
            inSDKString: *const PrSDKString,
            outUTF8StringBuffer: *mut prUTF8Char,
            ioUTF8StringBufferSizeInElements: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will allocate an SDKString from a passed in null terminated string.\n\n\t@param\tinUTF16String\t\t\tnull terminated UTF16 string to copy into the SDK string\n\t@param\tioSDKString\t\t\t\tthis passed in SDK string will receive the new allocated string\n\t\t\t\t\t\t\t\t\t\t- you must dispose of this sdk string\n\n\t@return suiteError_StringNotFound\tthis string has not been allocated, or may have already been disposed\n\t@return suiteError_InvalidParms\t\tone of the params is invalid"]
    pub AllocateFromUTF16: ::std::option::Option<
        unsafe extern "C" fn(
            inUTF16String: *const prUTF16Char,
            outSDKString: *mut PrSDKString,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will copy an SDKString into a UTF16 null terminated string if ioUTF16StringBufferByteCount reports enough bytes in\n\t\tthe string buffer to copy. If there are not enough bytes - suiteError_StringBufferTooSmall will be returned\n\t\tand ioUTF16StringBufferByteCount will contain the number of bytes needed to hold the string.\n\n\t@param\toutUTF16StringBuffer\t\t\t\tBuffer where UTF16 string will be stored\n\t@param\tioUTF16StringBufferSizeInElements\tPass in the size, in elements, of outUTF16StringStorage. Returns the number of elements copied.  Includes terminating 0.\n\n\t@return suiteError_InvalidParms\t\t\tOne of the params is invalid\n\t@return suiteError_StringBufferTooSmall\tThe passed in string buffer is too small. ioUTF16StringBufferByteCount will contain the number of bytes needed to copy this string.\n\t@return suiteError_NoError\t\t\t\tThe string has been copied. ioUTF16StringBufferByteCount contains the number of bytes copied."]
    pub CopyToUTF16String: ::std::option::Option<
        unsafe extern "C" fn(
            inSDKString: *const PrSDKString,
            outUTF16StringBuffer: *mut prUTF16Char,
            ioUTF16StringBufferSizeInElements: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
}
pub type ThreadedWorkCallback =
    ::std::option::Option<unsafe extern "C" fn(inInstanceData: *mut ::std::os::raw::c_void)>;
pub type ThreadedWorkCallbackVersion3 = ::std::option::Option<
    unsafe extern "C" fn(
        inInstanceData: *mut ::std::os::raw::c_void,
        inPluginID: csSDK_int32,
        inStatus: prSuiteError,
    ),
>;
pub type ThreadedWorkRegistration = *mut ::std::os::raw::c_void;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKThreadedWorkSuiteVersion2 {
    pub RegisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallback,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
    pub QueueThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(inRegistrationData: ThreadedWorkRegistration) -> prSuiteError,
    >,
    pub UnregisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(inRegistrationData: ThreadedWorkRegistration) -> prSuiteError,
    >,
    pub RegisterForSingleThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallback,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
}
#[doc = "\tThe following typedef is provided for short-term backwards compatibility only.\n\tClients should prefer the explicit versioned struct name."]
pub type PrSDKThreadedWorkSuite = PrSDKThreadedWorkSuiteVersion2;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKThreadedWorkSuiteVersion3 {
    pub RegisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallbackVersion3,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
    pub QueueThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inRegistrationData: ThreadedWorkRegistration,
            inPluginID: csSDK_int32,
        ) -> prSuiteError,
    >,
    pub UnregisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(inRegistrationData: ThreadedWorkRegistration) -> prSuiteError,
    >,
    pub RegisterForSingleThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallbackVersion3,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
}
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsCompletelyOpaque: PrNodeInfoFlag = 1;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsCompletelyTransparent: PrNodeInfoFlag = 2;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_DoesNotDependOnSequenceTime: PrNodeInfoFlag = 4;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_NodeDoesNotDependOnSegmentTime: PrNodeInfoFlag = 8;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_NodeDoesNotDependOnClipInOutTime: PrNodeInfoFlag = 16;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsNOP: PrNodeInfoFlag = 32;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_NodeDoesNotDependOnTrackInputs: PrNodeInfoFlag = 64;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsAdjustment: PrNodeInfoFlag = 128;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_MaxSize: PrNodeInfoFlag = -1;
pub type PrNodeInfoFlag = ::std::os::raw::c_int;
pub const kMaxNodeTypeStringSize: ::std::os::raw::c_int = 256;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Linear:
    PrKeyframeInterpolationModeFlag = 0;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Hold:
    PrKeyframeInterpolationModeFlag = 4;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Bezier:
    PrKeyframeInterpolationModeFlag = 5;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Time:
    PrKeyframeInterpolationModeFlag = 6;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_TimeTransitionStart:
    PrKeyframeInterpolationModeFlag = 7;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_TimeTransitionEnd:
    PrKeyframeInterpolationModeFlag = 8;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_MaxSize:
    PrKeyframeInterpolationModeFlag = -1;
pub type PrKeyframeInterpolationModeFlag = ::std::os::raw::c_int;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_None: PrNodeScalePolicy = 0;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_ScaleToFrame: PrNodeScalePolicy = 1;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_ScaleToFillCrop: PrNodeScalePolicy = 2;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_ScaleToFillDistort: PrNodeScalePolicy = 3;
pub type PrNodeScalePolicy = ::std::os::raw::c_int;
#[doc = "\tThis callback function is used by the property query methods. Iteration can be cancelled at\n\tany time by returning a result other than malNoError.\n\n\t@param\tinPluginObject\t\t\tA value (such as \"this\") passed by the plugin in the original call\n\t\t\t\t\t\t\t\t\tand passed back in the callback. May be NULL.\n\t@param\tinKey\t\t\t\t\tThe key for the property\n\t@param\tinValue\t\t\t\t\tThe value for the property"]
pub type SegmentNodePropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        inPluginObject: csSDK_int32,
        inKey: *const ::std::os::raw::c_char,
        inValue: *const prUTF8Char,
    ) -> prSuiteError,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKVideoSegmentSuite {
    #[doc = "\tFrom a sequence, get an ID to its video segments ID. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments"]
    pub AcquireVideoSegmentsID: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithPreviewsID: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted, but only previews\n\tfor sections that are opaque. This is appropriate for use when using previews for nested sequences. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tRecevies the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithOpaquePreviewsID: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tRelease a Video Segments ID\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID to release"]
    pub ReleaseVideoSegmentsID:
        ::std::option::Option<unsafe extern "C" fn(inVideoSegmentsID: csSDK_int32) -> prSuiteError>,
    #[doc = "\tGet the hash of a Video Segments object\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\toutHash\t\t\t\tThe GUID hash of the segments"]
    pub GetHash: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            outHash: *mut prPluginID,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of segments in the segments object\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\toutNumSegments\t\tThe number of segments"]
    pub GetSegmentCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            outNumSegments: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the details of the Nth Node.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinIndex\t\t\t\tWhich segment?\n\t@param\toutStartTime\t\tThe start time of the segment\n\t@param\toutEndTime\t\t\tThe end time of the segment\n\t@param\toutSegmentOffset\tThe offset value for the segment\n\t@param\toutHash\t\t\t\tThe hash for the segment"]
    pub GetSegmentInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inIndex: csSDK_int32,
            outStartTime: *mut PrTime,
            outEndTime: *mut PrTime,
            outSegmentOffset: *mut PrTime,
            outHash: *mut prPluginID,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a segment node. This object is ref-counted and must be released.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinHash\t\t\t\tThe hash for the segment\n\t@param\toutVideoNodeID\t\tThe video node ID."]
    pub AcquireNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inHash: *mut prPluginID,
            outVideoNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tRelease a Video Node ID\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID to release"]
    pub ReleaseVideoNodeID:
        ::std::option::Option<unsafe extern "C" fn(inVideoNodeID: csSDK_int32) -> prSuiteError>,
    #[doc = "\tGet details about a node.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutNodeType\t\t\tA string of size kMaxNodeTypeStringSize holding the node type\n\t@param\toutHash\t\t\t\tThe hash for the node (may be different than the hash used to get the node)\n\t@param\toutInfoFlags\t\tThe flags for this node (see enum above)"]
    pub GetNodeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outNodeType: *mut ::std::os::raw::c_char,
            outHash: *mut prPluginID,
            outFlags: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of inputs on the node object\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutNumInputs\t\tThe number of inputs"]
    pub GetNodeInputCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outNumInputs: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a segment node that is an input to another node. This object is ref-counted and must be released.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the input\n\t@param\toutOffset\t\t\tThe time offset relative to it's parent node\n\t@param\toutInputVideoNodeID\tThe video node ID of the input node."]
    pub AcquireInputNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            outOffset: *mut PrTime,
            outInputVideoNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of inputs on the node object\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutNumOperators\t\tThe number of operators"]
    pub GetNodeOperatorCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outNumOperators: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a segment node that is an operator on another node. This object is ref-counted and must be released.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the operator\n\t@param\toutOperatorVideoNodeID\tThe video node ID of the input node."]
    pub AcquireOperatorNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            outOperatorVideoNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tIterate all of the properties on a node.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinCallback\t\t\tThe callback function to return the properties\n\t@param\tinPluginObject\t\tThe plugin object returned in the callback."]
    pub IterateNodeProperties: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inCallback: SegmentNodePropertyCallback,
            inPluginObject: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the value of a single property on a node\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinKey\t\t\t\tThe key of the property\n\t@param\toutValue\t\t\tA string holding the value. This UTF8 string is allocated using PrNewPtr,\n\t\t\t\t\t\t\t\tand ownership is transferred to the plugin and must be disposed\n\t\t\t\t\t\t\t\tby the plugin."]
    pub GetNodeProperty: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inKey: *const ::std::os::raw::c_char,
            outValue: *mut PrMemoryPtr,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of params\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutParamCount\t\tThe number of params"]
    pub GetParamCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outParamCount: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a specific param value at a specific time\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the param\n\t@param\tinTime\t\t\t\tThe time requested (in Media time)\n\t@param\toutParam\t\t\tThe param"]
    pub GetParam: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            inTime: PrTime,
            outParam: *mut PrParam,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the next keyframe time after the specified time.\n\n\tExample: Keyframes at 0 and 10\n\tinTime = -1, outKeyframeTime = 0\n\tinTime = 0, outKeyframeTime = 10\n\tinTime = 9, outKeyframeTime = 10\n\tinTime = 10, returns suiteError_NoKeyframeAfterInTime\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the param\n\t@param\tinTime\t\t\t\tThe lower bound time\n\t@param\toutKeyframeTime\t\tThe time of the next keyframe > inTime\n\t@param\toutKeyframeInterpolationMode\tThe temporal interpolation mode of the keyframe, see\n\t\t\t\t\t\t\t\t\t\t\tthe enum for PrKeyframeInterpolationModeFlag above"]
    pub GetNextKeyframeTime: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            inTime: PrTime,
            outKeyframeTime: *mut PrTime,
            outKeyframeInterpolationMode: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tTransform a node local time into a time appropriate for node inputs and\n\toperators. When used on the clip node, for instance, this will take into\n\taccount speed change, reverse, time remapping and return a time value\n\twhich can be used in the Media and Effect nodes.\n\tIf the node does not have a time transform, function will not fail but\n\twill return in input time in the output."]
    pub TransformNodeTime: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inTime: PrTime,
            outTime: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tRetrieve general properties of a sequence (video segments). I.e. width/height, par and framerate.\n\n\t@param\tinTimelineID\t\t\t\t\tThe plugin timeline ID for the sequence\n\t@param\toutWidth\t\t\t\t\t\tReceives width of the sequence\n\t@param\toutHeight\t\t\t\t\t\tReceives height of the sequence\n\t@param\toutPixelAspectRatioNumerator\tReceives the pixel aspect ratio numerator of the sequence\n\t@param\toutPixelAspectRatioDenominator\tReceives the pixel aspect ratio denominator of the sequence\n\t@param\toutFrameRateNumerator\t\t\tReceives the frame rate numerator of the sequence\n\t@param\toutFrameRateDenominator\t\t\tReceives the frame rate denominator of the sequence"]
    pub GetVideoSegmentsProperties: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outBounds: *mut prRect,
            outPixelAspectRatioNumerator: *mut csSDK_int32,
            outPixelAspectRatioDenominator: *mut csSDK_int32,
            outFrameRate: *mut PrTime,
            outFieldType: *mut prFieldType,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get a segment node for a requested time. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinTime\t\t\t\tRequested segment time\n\t@param\toutVideoNodeID\t\tThe video node ID\n\t@param\toutSegmentOffset\tOffset of retrieved segment"]
    pub AcquireNodeForTime: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inTime: PrTime,
            outVideoNodeID: *mut csSDK_int32,
            outSegmentOffset: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments"]
    pub AcquireVideoSegmentsIDWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithPreviewsIDWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted, but only previews\n\tfor sections that are opaque. This is appropriate for use when using previews for nested sequences. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tRecevies the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithOpaquePreviewsIDWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get the first segment node that intersects with a range of times.\n  This is a ref-counted object, and must be released when no longer needed.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinStartTime\t\t\tThe start of the requested segment time range\n\t@param\tinEndTime\t\t\tThe end of the requested segment time range\n\t@param\toutVideoNodeID\t\tThe video node ID\n\t@param\toutSegmentOffset\tOffset of retrieved segment"]
    pub AcquireFirstNodeInTimeRange: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inStartTime: PrTime,
            inEndTime: PrTime,
            outVideoNodeID: *mut csSDK_int32,
            outSegmentOffset: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tAcquire the node owning an operator\n\n\t@param\tinVideoNodeID\t\tThe operator\n\t@param\toutOwnerNodeID\t\tThe owner"]
    pub AcquireOperatorOwnerNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outOwnerNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet graphic layer params at a specific time\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinTime\t\t\t\tThe time requested (in Media time)"]
    pub GetGraphicsTransformedParams: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inTime: PrTime,
            outPosition: *mut prFPoint64,
            outAnchor: *mut prFPoint64,
            outScale: *mut prFPoint64,
            outRotation: *mut f32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet graphic layer group ID\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID"]
    pub HasGraphicsGroup: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outHasGraphicGroup: *mut bool,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet graphic layer group ID\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID"]
    pub GetGraphicsGroupID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outGroupID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = " Color managed version of GetVideoSegmentsProperties\n\tRetrieve general properties of a sequence (video segments). I.e. width/height, par and framerate\n and color space\n\n\t@param\tinTimelineID\t\t\t\t\tThe plugin timeline ID for the sequence\n\t@param\toutWidth\t\t\t\t\t\tReceives width of the sequence\n\t@param\toutHeight\t\t\t\t\t\tReceives height of the sequence\n\t@param\toutPixelAspectRatioNumerator\tReceives the pixel aspect ratio numerator of the sequence\n\t@param\toutPixelAspectRatioDenominator\tReceives the pixel aspect ratio denominator of the sequence\n\t@param\toutFrameRateNumerator\t\t\tReceives the frame rate numerator of the sequence\n\t@param\toutFrameRateDenominator\t\t\tReceives the frame rate denominator of the sequence\n @param\toutColorSpaceID\t\t\t\t\tReceives the opaque ID of the sequence's working color space"]
    pub GetVideoSegmentsPropertiesExt: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outBounds: *mut prRect,
            outPixelAspectRatioNumerator: *mut csSDK_int32,
            outPixelAspectRatioDenominator: *mut csSDK_int32,
            outFrameRate: *mut PrTime,
            outFieldType: *mut prFieldType,
            outColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get the first segment node that intersects with a range of times.\n  This is a ref-counted object, and must be released when no longer needed.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinStartTime\t\t\tThe start of the requested segment time range\n\t@param\tinEndTime\t\t\tThe end of the requested segment time range\n\t@param\toutVideoNodeID\t\tThe video node ID\n\t@param\toutSegmentStartTime\tStart time of retrieved segment\n\t@param\toutSegmentEndTime\tEnd time of retrieved segment\n\t@param\toutSegmentOffset\tOffset of retrieved segment"]
    pub AcquireFirstNodeInTimeRangeExt: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inStartTime: PrTime,
            inEndTime: PrTime,
            outVideoNodeID: *mut csSDK_int32,
            outSegmentStartTime: *mut PrTime,
            outSegmentEndTime: *mut PrTime,
            outSegmentOffset: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tReturns the relative time rate of a node at a given point in time.\n  Node time rate varies with e.g. time remapping but not the playback speed of the sequence\n  Can be thought of as the instantaneous rate of change of TransformNodeTime()\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinTime\t\t\t\tThe time requested (in Media time - untransformed)\n\t@param\toutRate\t\t\t\tThe node rate relative to the containing sequence"]
    pub GetNodeTimeScale: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inTime: PrTime,
            outRate: *mut f64,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKWindowSuite {
    pub GetMainWindow: ::std::option::Option<unsafe extern "C" fn() -> prWnd>,
    pub UpdateAllWindows: ::std::option::Option<unsafe extern "C" fn()>,
}
pub type A_long = i32;
pub type A_u_long = u32;
pub type A_char = ::std::os::raw::c_char;
pub type A_FpLong = f64;
pub type A_FpShort = f32;
pub type A_short = ::std::os::raw::c_short;
pub type A_u_short = ::std::os::raw::c_ushort;
pub type A_u_char = ::std::os::raw::c_uchar;
pub type A_Boolean = ::std::os::raw::c_uchar;
pub type A_intptr_t = ::std::os::raw::c_longlong;
pub type A_u_longlong = ::std::os::raw::c_ulonglong;
pub type PF_Stage = A_long;
pub type PF_Quality = A_long;
pub type PF_ModeFlags = A_long;
pub type PF_Field = A_long;
pub type PF_ParamType = A_long;
pub type PF_ParamFlags = A_long;
pub type PF_Err = A_long;
pub type PF_WorldFlags = A_long;
pub type PF_OutFlags = A_long;
pub type PF_OutFlags2 = A_long;
pub type PF_InFlags = A_long;
pub type PF_Cmd = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_LayerAudio {
    _unused: [u8; 0],
}
#[doc = " -------------------- Simple Types --------------------"]
pub type PF_LayerAudio = *mut _PF_LayerAudio;
pub type PF_SndSamplePtr = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ProgressInfo {
    _unused: [u8; 0],
}
pub type PF_ProgPtr = *mut PF_ProgressInfo;
pub type PF_ParamValue = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SpecVersion {
    pub major: A_short,
    pub minor: A_short,
}
pub type PF_ParamIndex = A_long;
pub type PF_UFixed = A_u_long;
pub type PF_Fixed = A_long;
pub type PF_Boolean = A_char;
pub type PF_Handle = *mut *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LegacyPoint {
    pub v: A_short,
    pub h: A_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LegacyRect {
    pub top: A_short,
    pub left: A_short,
    pub bottom: A_short,
    pub right: A_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Point {
    pub h: A_long,
    pub v: A_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LRect {
    pub left: A_long,
    pub top: A_long,
    pub right: A_long,
    pub bottom: A_long,
}
pub type PF_Rect = PF_LRect;
pub type PF_UnionableRect = PF_Rect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_RationalScale {
    pub num: A_long,
    pub den: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FixedPoint {
    pub x: PF_Fixed,
    pub y: PF_Fixed,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FixedRect {
    pub left: PF_Fixed,
    pub top: PF_Fixed,
    pub right: PF_Fixed,
    pub bottom: PF_Fixed,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Matrix {
    pub mat: [[PF_Fixed; 3usize]; 3usize],
}
pub type PF_TransferMode = A_long;
pub type PF_XferMode = PF_TransferMode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Pixel {
    pub alpha: A_u_char,
    pub red: A_u_char,
    pub green: A_u_char,
    pub blue: A_u_char,
}
pub type PF_Pixel8 = PF_Pixel;
pub type PF_UnionablePixel = PF_Pixel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Pixel16 {
    pub alpha: A_u_short,
    pub red: A_u_short,
    pub green: A_u_short,
    pub blue: A_u_short,
}
pub type PF_FpShort = A_FpShort;
pub type PF_FpLong = A_FpLong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PixelFloat {
    pub alpha: PF_FpShort,
    pub red: PF_FpShort,
    pub green: PF_FpShort,
    pub blue: PF_FpShort,
}
pub type PF_Pixel32 = PF_PixelFloat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FloatMatrix {
    pub mat: [[PF_FpLong; 3usize]; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_CompositeMode {
    pub xfer: PF_TransferMode,
    pub rand_seed: A_long,
    pub opacity: A_u_char,
    pub rgb_only: PF_Boolean,
    pub opacitySu: A_u_short,
}
pub type PF_PixLong = A_u_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_PixelOpaque {
    _unused: [u8; 0],
}
pub type PF_PixelOpaquePtr = *mut _PF_PixelOpaque;
pub type PF_PixelPtr = *mut PF_Pixel;
pub type PF_RGB_Pixel = [PF_Fixed; 3usize];
pub type PF_YIQ_Pixel = [PF_Fixed; 3usize];
pub type PF_HLS_Pixel = [PF_Fixed; 3usize];
pub type PF_ChannelType = A_long;
pub type PF_DataType = A_long;
#[doc = " for enumerating over all the channels"]
pub type PF_ChannelIndex = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ChannelDesc {
    pub channel_type: PF_ChannelType,
    pub name: [A_char; 64usize],
    pub data_type: PF_DataType,
    pub dimension: A_long,
}
#[doc = " the opaque type representing the channel data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ChannelRef {
    pub opaque: [A_intptr_t; 8usize],
}
#[doc = " the opaque type representing the channel data"]
pub type PF_ChannelRefPtr = *mut PF_ChannelRef;
#[doc = " the channel data parallels the image data in size and shape.\n the width is the number of pixels, the height is the number of scanlines\n the height is image_height\n the dimension is the number of planes in a pixel\n the row_bytes is the length of a scanline in bytes\n the data type is the type of data in a plane\n\tNote : a pixel consists of dimensionL * sizeof(data_type) bytes\n dataH is a handle to the data.\n dataPV is a pointer to the dereferenced locked handle\n effects should always have dataPV non null."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ChannelChunk {
    pub channel_ref: PF_ChannelRef,
    pub widthL: A_long,
    pub heightL: A_long,
    pub dimensionL: A_long,
    pub row_bytesL: A_long,
    pub data_type: PF_DataType,
    pub dataH: PF_Handle,
    pub dataPV: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LayerDef {
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub world_flags: PF_WorldFlags,
    pub data: PF_PixelPtr,
    pub rowbytes: A_long,
    pub width: A_long,
    pub height: A_long,
    pub extent_hint: PF_UnionableRect,
    pub platform_ref: *mut ::std::os::raw::c_void,
    pub reserved_long1: A_long,
    pub reserved_long4: *mut ::std::os::raw::c_void,
    pub pix_aspect_ratio: PF_RationalScale,
    pub reserved_long2: *mut ::std::os::raw::c_void,
    pub origin_x: A_long,
    pub origin_y: A_long,
    pub reserved_long3: A_long,
    pub dephault: A_long,
}
pub type PF_EffectWorld = PF_LayerDef;
pub type PF_SoundFormat = A_short;
pub type PF_SoundSampleSize = A_short;
pub type PF_SoundChannels = A_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SoundFormatInfo {
    pub rateF: PF_FpLong,
    pub num_channels: PF_SoundChannels,
    pub format: PF_SoundFormat,
    pub sample_size: PF_SoundSampleSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SoundWorld {
    pub fi: PF_SoundFormatInfo,
    pub num_samples: A_long,
    pub dataP: *mut ::std::os::raw::c_void,
}
pub type PF_ValueDisplayFlags = A_short;
#[doc = " Slider -- PF_Param_SLIDER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SliderDef {
    pub value: PF_ParamValue,
    pub value_str: [A_char; 32usize],
    pub value_desc: [A_char; 32usize],
    pub valid_min: PF_ParamValue,
    pub valid_max: PF_ParamValue,
    pub slider_min: PF_ParamValue,
    pub slider_max: PF_ParamValue,
    pub dephault: PF_ParamValue,
}
#[doc = " Fixed Point Slider -- PF_Param_FIX_SLIDER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FixedSliderDef {
    pub value: PF_Fixed,
    pub value_str: [A_char; 32usize],
    pub value_desc: [A_char; 32usize],
    pub valid_min: PF_Fixed,
    pub valid_max: PF_Fixed,
    pub slider_min: PF_Fixed,
    pub slider_max: PF_Fixed,
    pub dephault: PF_Fixed,
    pub precision: A_short,
    pub display_flags: PF_ValueDisplayFlags,
}
pub type PF_FSliderFlags = A_u_long;
#[doc = " Floating Point Slider -- PF_Param_FLOAT_SLIDER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FloatSliderDef {
    pub value: PF_FpLong,
    pub phase: PF_FpLong,
    pub value_desc: [A_char; 32usize],
    pub valid_min: PF_FpShort,
    pub valid_max: PF_FpShort,
    pub slider_min: PF_FpShort,
    pub slider_max: PF_FpShort,
    pub dephault: PF_FpShort,
    pub precision: A_short,
    pub display_flags: PF_ValueDisplayFlags,
    pub fs_flags: PF_FSliderFlags,
    pub curve_tolerance: PF_FpShort,
    pub useExponent: PF_Boolean,
    pub exponent: PF_FpShort,
}
#[doc = " Angle -- PF_Param_ANGLE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_AngleDef {
    pub value: PF_Fixed,
    pub dephault: PF_Fixed,
    pub valid_min: PF_Fixed,
    pub valid_max: PF_Fixed,
}
#[doc = " CheckBox -- PF_Param_CHECKBOX"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_CheckBoxDef {
    pub value: PF_ParamValue,
    pub dephault: PF_Boolean,
    pub reserved: A_char,
    pub reserved1: A_short,
    pub u: PF_CheckBoxDef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_CheckBoxDef__bindgen_ty_1 {
    pub nameptr: *const A_char,
}
#[doc = " Color -- PF_Param_COLOR"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ColorDef {
    pub value: PF_UnionablePixel,
    pub dephault: PF_UnionablePixel,
}
#[doc = " Point -- PF_Param_POINT\n\nThe values for the point use the source's coordinate system, with the\norigin at the top left. The values are expressed in fixed point, with\n16 bits of fractional precision (out of a total of 32 bits).\n\nThe dephaults (sorry) are expressed as percentages (with 16 bits of\nfraction) with the origin at the top left. The percent can be negative,\nbut should not be smaller than -600%. It should not be greater than 600%.\n\nIf restrict_bounds is TRUE, the user will not be allowed to specify\npoints outside the bounds of the layer to which they are applying the\neffect. If this is TRUE, the dephaults should be between 0.0 and 100.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PointDef {
    pub x_value: PF_Fixed,
    pub y_value: PF_Fixed,
    pub reserved: [A_char; 3usize],
    pub restrict_bounds: PF_Boolean,
    pub x_dephault: PF_Fixed,
    pub y_dephault: PF_Fixed,
}
#[doc = " 3D Point -- PF_Param_POINT_3D\n\nJust like POINT, with an extra dimension. Supported in AE starting with version 10.5 (CS 5.5)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Point3DDef {
    pub x_value: PF_FpLong,
    pub y_value: PF_FpLong,
    pub z_value: PF_FpLong,
    pub x_dephault: PF_FpLong,
    pub y_dephault: PF_FpLong,
    pub z_dephault: PF_FpLong,
    pub reserved: [::std::os::raw::c_char; 16usize],
}
#[doc = " Popup Menu -- PF_Param_POPUP\n\n can also be used as a radio-button group in some hosts\n when PF_PUI_RADIO_BUTTON is set\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_PopupDef {
    pub value: PF_ParamValue,
    pub num_choices: A_short,
    pub dephault: A_short,
    pub u: PF_PopupDef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_PopupDef__bindgen_ty_1 {
    pub namesptr: *const A_char,
}
#[doc = " Momentary Buttons -- PF_Param_BUTTON\n\n supported by AE starting with CS 5.5 (AE 10.5); may be supported in other hosts\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_ButtonDef {
    pub value: PF_ParamValue,
    pub u: PF_ButtonDef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ButtonDef__bindgen_ty_1 {
    pub namesptr: *const A_char,
}
pub type PF_PathID = A_u_long;
pub type PF_MaskMode = A_long;
#[doc = " Path -- PF_Param_PATH\n\nPath parameters give access to the mask/path/shapes of the layer on which\nthe effect is applied.  For more information\non how to use these paths, see the PF_PathQuerySuite, and the PF_PathDataSuite\nin AE_EffectSuites.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PathDef {
    pub path_id: PF_PathID,
    pub reserved0: A_long,
    pub dephault: A_long,
}
pub type PF_ArbitraryH = PF_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbitraryDef {
    pub id: A_short,
    pub pad: A_short,
    pub dephault: PF_ArbitraryH,
    pub value: PF_ArbitraryH,
    pub refconPV: *mut ::std::os::raw::c_void,
}
pub type PF_FunctionSelector = A_long;
pub type PF_ArbCompareResult = A_long;
pub type PF_ArbPrintFlags = A_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_ArbParamsExtra {
    pub which_function: PF_FunctionSelector,
    pub id: A_short,
    pub padding: A_short,
    pub u: PF_ArbParamsExtra__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ArbParamsExtra__bindgen_ty_1 {
    pub new_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_1,
    pub dispose_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_2,
    pub copy_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_3,
    pub flat_size_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_4,
    pub flatten_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_5,
    pub unflatten_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_6,
    pub interp_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_7,
    pub compare_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_8,
    pub print_size_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_9,
    pub print_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_10,
    pub scan_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_1 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_2 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_3 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub src_arbH: PF_ArbitraryH,
    pub dst_arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_4 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
    pub flat_data_sizePLu: *mut A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_5 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
    pub buf_sizeLu: A_u_long,
    pub flat_dataPV: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_6 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub buf_sizeLu: A_u_long,
    pub flat_dataPV: *const ::std::os::raw::c_void,
    pub arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_7 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub left_arbH: PF_ArbitraryH,
    pub right_arbH: PF_ArbitraryH,
    pub tF: PF_FpLong,
    pub interpPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_8 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub a_arbH: PF_ArbitraryH,
    pub b_arbH: PF_ArbitraryH,
    pub compareP: *mut PF_ArbCompareResult,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_9 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
    pub print_sizePLu: *mut A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_10 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub print_flags: PF_ArbPrintFlags,
    pub arbH: PF_ArbitraryH,
    pub print_sizeLu: A_u_long,
    pub print_bufferPC: *mut A_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_11 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub bufPC: *const A_char,
    pub bytes_to_scanLu: A_u_long,
    pub arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UserChangedParamExtra {
    pub param_index: PF_ParamIndex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ImporterPrefsData {
    _unused: [u8; 0],
}
pub type PF_ImporterPrefsDataPtr = *mut PF_ImporterPrefsData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_TranslateParamsToPrefsExtra {
    pub prefsPC: PF_ImporterPrefsDataPtr,
    pub prefs_sizeLu: A_u_long,
}
pub type PF_DepCheckType = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ExtDependenciesExtra {
    pub check_type: PF_DepCheckType,
    pub dependencies_strH: PF_Handle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ParamDefUnion {
    pub ld: PF_LayerDef,
    pub sd: PF_SliderDef,
    pub fd: PF_FixedSliderDef,
    pub ad: PF_AngleDef,
    pub bd: PF_CheckBoxDef,
    pub cd: PF_ColorDef,
    pub td: PF_PointDef,
    pub pd: PF_PopupDef,
    pub fs_d: PF_FloatSliderDef,
    pub arb_d: PF_ArbitraryDef,
    pub path_d: PF_PathDef,
    pub button_d: PF_ButtonDef,
    pub point3d_d: PF_Point3DDef,
}
pub type PF_ParamUIFlags = A_long;
pub type PF_ChangeFlags = A_long;
#[doc = " ParamDef"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_ParamDef {
    pub uu: PF_ParamDef__bindgen_ty_1,
    pub ui_flags: PF_ParamUIFlags,
    pub ui_width: A_short,
    pub ui_height: A_short,
    pub param_type: PF_ParamType,
    pub name: [A_char; 32usize],
    pub flags: PF_ParamFlags,
    pub unused: A_long,
    pub u: PF_ParamDefUnion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ParamDef__bindgen_ty_1 {
    pub id: A_long,
    pub change_flags: PF_ChangeFlags,
}
#[doc = " ParamDef"]
pub type PF_ParamDefPtr = *mut PF_ParamDef;
#[doc = " ParamDef"]
pub type PF_ParamDefH = *mut *mut PF_ParamDef;
pub type PF_ParamList = *mut *mut PF_ParamDef;
pub type PF_ChannelMask = A_long;
pub type PF_GPU_Framework = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_RenderRequest {
    pub rect: PF_LRect,
    pub field: PF_Field,
    pub channel_mask: PF_ChannelMask,
    pub preserve_rgb_of_zero_alpha: PF_Boolean,
    pub unused: [::std::os::raw::c_char; 3usize],
    pub reserved: [A_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderInput {
    pub output_request: PF_RenderRequest,
    pub bitdepth: ::std::os::raw::c_short,
    pub gpu_data: *const ::std::os::raw::c_void,
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
pub type PF_DeletePreRenderDataFunc =
    ::std::option::Option<unsafe extern "C" fn(pre_render_data: *mut ::std::os::raw::c_void)>;
pub type PF_RenderOutputFlags = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderOutput {
    pub result_rect: PF_LRect,
    pub max_result_rect: PF_LRect,
    pub solid: PF_Boolean,
    pub reserved: PF_Boolean,
    pub flags: PF_RenderOutputFlags,
    pub pre_render_data: *mut ::std::os::raw::c_void,
    pub delete_pre_render_data_func: PF_DeletePreRenderDataFunc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_CheckoutResult {
    pub result_rect: PF_LRect,
    pub max_result_rect: PF_LRect,
    pub par: PF_RationalScale,
    pub solid: PF_Boolean,
    pub reservedB: [PF_Boolean; 3usize],
    pub ref_width: A_long,
    pub ref_height: A_long,
    pub reserved: [A_long; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderCallbacks {
    pub checkout_layer: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            checkout_idL: A_long,
            req: *const PF_RenderRequest,
            what_time: A_long,
            time_step: A_long,
            time_scale: A_u_long,
            checkout_result: *mut PF_CheckoutResult,
        ) -> PF_Err,
    >,
    pub GuidMixInPtr: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            buf_sizeLu: A_u_long,
            buf: *const ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderExtra {
    pub input: *mut PF_PreRenderInput,
    pub output: *mut PF_PreRenderOutput,
    pub cb: *mut PF_PreRenderCallbacks,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SmartRenderInput {
    pub output_request: PF_RenderRequest,
    pub bitdepth: ::std::os::raw::c_short,
    pub pre_render_data: *mut ::std::os::raw::c_void,
    pub gpu_data: *const ::std::os::raw::c_void,
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SmartRenderCallbacks {
    pub checkout_layer_pixels: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            checkout_idL: A_long,
            pixels: *mut *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub checkin_layer_pixels: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, checkout_idL: A_long) -> PF_Err,
    >,
    pub checkout_output: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, output: *mut *mut PF_EffectWorld) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SmartRenderExtra {
    pub input: *mut PF_SmartRenderInput,
    pub cb: *mut PF_SmartRenderCallbacks,
}
#[doc = " -------------------- GPU Setup/Setdown Constants and Structures --------------------\n\nPF_Cmd_GPU_DEVICE_SETUP gets a PF_GPUDeviceSetupExtra struct in the extra pointer.\n\nPF_Cmd_GPU_DEVICE_SETDOWN gets a PF_GPUDeviceSetdownExtra struct in the extra pointer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetupInput {
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetupOutput {
    pub gpu_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetupExtra {
    pub input: *mut PF_GPUDeviceSetupInput,
    pub output: *mut PF_GPUDeviceSetupOutput,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetdownInput {
    pub gpu_data: *mut ::std::os::raw::c_void,
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetdownExtra {
    pub input: *mut PF_GPUDeviceSetdownInput,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_CustomUIInfo {
    _unused: [u8; 0],
}
#[doc = " -------------------- Interaction Callbacks --------------------\n\nEffects modules use callbacks to define their parameters.  When invoked,\nthey will be given the parameters values at the particular invocation\nmoment, but some effects may need to ask for the parameter values at\nother times (notably of layer parameters for, say, a visual echo).\n\nWhile running, effects modules are responsible for checking for user\ninterrupts.  This checking can be done with either the abort callback,\nwhich will return a value indicating if the user has taken any action,\nor with the progress callback, which performs user interrupt checking\njust like the abort callback, and also displays a progress display.\n\nAt the bottom of this section are macros for accessing these callback\nroutines.  The first parameter to each macro is a pointer to a PF_InData\nstructure, defined below.  This pointer will be passed to your effect.\n\ncheckout_param\nThe checkout_param callback allows you to inquire param values at times\nother than the current one, and allows you to access layer params other\nthan the default input layer and the output layer.  See the notes on the\n\"params\" structure at the end of this file.  The PF_ParamDef you must\nspecify cannot point into the \"params\" array; the memory must exist else-\nwhere, such as on the stack.\n\nIf you checkout a layer parameter and the layer popup is currently set\nto <none>, the return value will be filled with zeros.  You can check\nthe \"data\" pointer.  If it is NULL, then the layer param is set to <none>\nand you should do something like faking an all alpha zero layer or some\nsuch nonsense.  IMPORTANT: Due to 13.5 threading changes, checking out\na layer param that is not <none> inside of UPDATE_PARAMS_UI will return\na frame with black pixels to avoid render requests and possible deadlock.\nIn other selectors the actual render will be triggered as it did before.\n\ncheckin_param\nWhen you have called checkout_param, you must call checkin_param when you\nare done, so After Effects can clean up after itself and you.  This is\nvery important for smooth functioning and also to save memory where possible.\nOnce checked in, the fields in the PF_ParamDef will no longer be valid.\n\nadd_param\nWhen given the PARAMS_SETUP message, the effect will generally make a\nseries of calls to the add_param routine to define the interface that\nthe After Effects user will see.  See the PF_ParamDefs defined above.\nCurrently you can only add params at the end, and only at PARAMS_SETUP\ntime.\n\nabort\nPeriodically, you should check if the user wants to interrupt the\ncurrent processing.  The abort proc here will return non-zero if\nthe effects module should suspend its current processing.  If you\ncall this routine and it returns a value other than zero, you should\nreturn that value when your effect returns.  That will let us know\nif the effect completed rendering or not.\n\nprogress\nAlternatively, you may wish to display a progress bar while you are\nprocessing the image.  This routine combines the abort proc user\ninterrupt checking with code that will display a progress bar for\nyou.  The current and total params represent a fraction (current/total)\nthat describes how far you are along in your processing.  Current\nshould equal total when done.  Additionally, this routine will return\nnon-zero if you should suspend/abort your current processing.  You\nshould probably try not to call this too frequently (e.g. at every pixel).\nIt is better to call it, say, once per scanline, unless your filter is\nreally really slow."]
pub type PF_CustomUIInfo = _PF_CustomUIInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_InteractCallbacks {
    pub checkout_param: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            what_time: A_long,
            time_step: A_long,
            time_scale: A_u_long,
            param: *mut PF_ParamDef,
        ) -> PF_Err,
    >,
    pub checkin_param: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, param: *mut PF_ParamDef) -> PF_Err,
    >,
    pub add_param: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            def: PF_ParamDefPtr,
        ) -> PF_Err,
    >,
    pub abort: ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub progress: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, current: A_long, total: A_long) -> PF_Err,
    >,
    pub register_ui: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, cust_info: *mut PF_CustomUIInfo) -> PF_Err,
    >,
    pub checkout_layer_audio: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            start_time: A_long,
            duration: A_long,
            time_scale: A_u_long,
            rate: PF_UFixed,
            bytes_per_sample: A_long,
            num_channels: A_long,
            fmt_signed: A_long,
            audio: *mut PF_LayerAudio,
        ) -> PF_Err,
    >,
    pub checkin_layer_audio: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, audio: PF_LayerAudio) -> PF_Err,
    >,
    pub get_audio_data: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            audio: PF_LayerAudio,
            data0: *mut PF_SndSamplePtr,
            num_samples0: *mut A_long,
            rate0: *mut PF_UFixed,
            bytes_per_sample0: *mut A_long,
            num_channels0: *mut A_long,
            fmt_signed0: *mut A_long,
        ) -> PF_Err,
    >,
    pub reserved_str: [*mut ::std::os::raw::c_void; 3usize],
    pub reserved: [*mut ::std::os::raw::c_void; 10usize],
}
#[doc = " -------------------- Effect Parameter Blocks --------------------\n\nThe effects module itself is invoked with input and output blocks\nof parameters for various messages that it needs to handle.  The\noutput block (values returned from the effect to the program) and\nthe input block (values provided by the program for the edification\nof the effect) are defined here.  Discussion follows.\n\nThe Output Block\n\nMost fields of the output block are only examined for changes after\ncertain commands have been sent to the effect module.  Each field\nbelow describes when it will be checked.\n\nmy_version\nThis is the version number of your plug-in effect, not to be confused\nwith the version of the plug-in specification. Please set this\nat PF_Cmd_GLOBAL_SETUP.\n\nname\nThis lets you override the name of the effect in the Time Layout and\nin the Effect Controls windows when the effect is applied. The name from\nthe PiPL resource is always used in the Effect menu. This field is\nchecked after PF_Cmd_SEQUENCE_SETUP. You will almost always leave\nthis field empty.\n\nglobal_data\nThis is a Handle that you can allocate at PF_Cmd_GLOBAL_SETUP\ntime.  It will be passed back to you verbatim in the input\nparameter block for use later on.  In PF_Cmd_GLOBAL_SETUP,\nthe global_data field in the Input Block may be set to a\nflattened version of your global data, in which case you should\nunflatten it, free the flat version, and set this field to the\nunflattened new global data.\n\nIt will be locked & unlocked for you automatically like sequence_data.\n\nnum_params\nThe calling application will sanity check the num_params field\nvs the times add_param is called.  The implicit main\nlayer parameter MUST be included in the parameter count.  Use the\nnum_params value in the in_data as a starting value (it will\ninclude the implicit layer parameter).\nSet this field when you get PF_Cmd_PARAMS_SETUP.\n\nsequence_data\nThis is a Handle that you can allocate (using PF_NEW_HANDLE)\nat PF_Cmd_SEQUENCE_SETUP time.\nIt will be passed back to you in the input parameter block\nfor later use.\n\nWARNING: this handle is always locked for you before your plugin\nis called, and the lock-state is restored on the way out.  If you\nhave arbitrary data, your plugin can be called re-entrantly, so\nif you have a lock/unlock inside your plugin, the handle will\nbecome unlocked prematurely -- instead simply depend on the host\nto lock & unlock your sequence data for you.  Of course during\nPF_Cmd_SEQUENCE_SETUP the handle you allocate will not be\nlocked unless you explicitly lock it at that time.\n\nThe contents of this handle will be written out to\ndisk.  If other handles\thang off this block, you must specify the\nPF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING out flag when you get\nthe PF_Cmd_GLOBAL_SETUP command.  You will then receive the\nPF_Cmd_SEQUENCE_FLATTEN before your handle is written out.  At that\ntime, you should create a flat version of the handle contents,\nfree the old unflat handle, and set this field to the flattened\nversion of the handle.  Or after disposing, simply set to NULL\nand nothing will be written to disk.\n\nYou will receive a PF_Cmd_SEQUENCE_RESETUP\ncall to unflatten this handle (as well as to adjust the sequence\ndata to altered frame rates, etc).  If your\nsequence data can be flat or unflat, you should store its current\nstate along with the other data, and check that value in Resetup.\nIf the handle is flat, Resetup should unflatten it, free the flat\nhandle, and set this field to the new unflat usable handle.\n\nflat_sdata_size\nOBSOLETE.  Turns out, it was never used.  Since the handle\nset in sequence_data must be allocated using PF_NEW_HANDLE,\nthe host can find out the size of the handle without asking.\n\nframe_data\nThis is a Handle that you can allocated at PF_Cmd_FRAME_SETUP\ntime.  It will be passed to you in the input parameters, as\nwith the global_data and the sequence_data.  This will not\nbe written out to disk.  There is no particular use for this.\nSet this field in PF_Cmd_FRAME_SETUP, if you must.\n\nIt will be locked & unlocked for you like sequence_data.\n\nwidth\nheight\norigin\nYou set these fields at PF_Cmd_FRAME_SETUP time to indicate\nthat the output image will be larger than the input image.\nYou\tshould set width and height to the size that you want the\noutput buffer to be.  Set origin to the place that the\npoint (0,0) in the input should map to in the new larger\noutput.  Thus, if you created a 5 pixel drop shadow up and left,\nyou would set origin to (5, 5).\n\nout_flags\nout_flags2\nThis field can be set to an OR-ed combination of the PF_OutFlag\nand PF_OutFlag2 constants (don't mix them up!) to communicate\nthings to After Effects.  This will be checked after every\ncommand, but only certain flags are relevant at given times.\nCheck the PF_OutFlag constants above.\n\nreturn_msg\nThis is a message string (in C string format) that will be\ninterpreted as either an error message or a useful display\nmessage (for instance, for handling PF_Cmd_ABOUT).  Fill\nthis string with a message you want After Effects to report\nto the user for you.  It will come up in a simple dialog\nwith an OK button.  Set the first byte of this string to '\\0'\nto indicate no string -- it is set that way upon entry.  This\nfield is examined after every PF_Cmd.\n\nThe Input Block\n\nMany parts of the input block are actually structures defined elsewhere\nin this file, or in the companion file AE_EffectCB.h.  See the documentation\nwhere those structures are defined to understand their contents.\nWith any given PF_Cmd, only certain fields in the Input Block will\nhave valid values.  Each field described below tells when it is valid.\n\nin_flags\nin_flags2\nThese are various flags indicating some boolean value to\nthe effect module.  This is a combination of PF_InFlag values\nOR-ed together.  This is set for all commands, though most\nflags make sense only at certain times.  Usually this is\njust a copy of the PiPL global flags.  See PF_OutFlags and\nPF_OutFlags2 above.\n\ninter\nThis is a structure defined above containing callbacks\nrelated to user interaction.  This has callbacks to add parameters,\nto check if the user has interrupted the effect, to display\na progress bar, and to inquire parameter values outside of the\ncurrent moment.  See the doc above.  When each callback can\nvalidly be executed is defined above.\n\nutils\nThis is a pointer to a block of useful graphical and mathematical\ncallbacks provided for the effects module.  The documentation\nfor this block is in the AE_EffectCB.h file.  This is a void *,\nwhich can be confusing.  See AE_EffectCB.h for macros to use these\nfunctions.  This pointer will be defined at all times.\n\neffect_ref\nThis is a opaque piece of data that needs to be passed to\nmost of the various callback routines.  Don't worry about it.\n\nquality\nThis is set to one of the PF_Quality constants above to\ndescribe the Quality currently chosen by the user.  Ideally,\nyour effect should do a faster version with LO quality, and\na better, \"broadcast\"-able version with HI quality.  Also,\nsome of the utility callbacks perform differently between\nLO and HI quality.  This is defined for all PF_Cmds related\nto SEQUENCE and FRAME (obviously, including RENDER).\n\nversion\nThis is the version of the effects spec with which you are\nbeing invoked.  This will not be defined until after GLOBAL_SETUP.\n\nserial_num\nThis is the serial number of the invoking application.\n\nappl_id\nThis is the identifier of the invoking application.  It will\nbe the creator A_long of the app.\n\nfreq\nThis is an estimate of the frequency with which you should\ncall the abort check callback.  You can ignore this.\n\nnum_params\nThis is set to the number of input parameters you are receiving.\n\nwhat_cpu\nThis is set to the return value from Gestalt asking what sort\nof CPU your machine has.  If your effect requires a certain\ntype of CPU it should check this value and return an error\nindicating that it cannot run.  After Effects only runs on\n68020s and higher, so don't sweat it if you require that.\n\nwhat_fpu\nThis is set to the return value from Gestalt asking what sort\nof FPU your machine has.  If you require a floating point unit,\nyou should return the OutFlag indicating that in GLOBAL_SETUP,\nand then do not execute your floating point code if this value\nis set to 0 -- just do a PF_COPY of the input to the output when\nyou get the PF_Cmd_RENDER.  See OutFlag description above.\n\ncurrent_time\nThis is the time of the current frame.  It will be set in RENDER.\nThe number of the current frame is current_time / time_step.\nAll effects sequences start at time 0.\n\ntime_step\nThis is the time difference to the next or last frame.  This value\nand current_time and total_time are in units given by time_scale.\nThe time between frames is time_step, not 1.  This value will be 0\nat SEQUENCE_SETUP if it is not constant for all frames.  It will\nbe set correctly in the FRAME calls, even if it's not constant.\n\ntotal_time\nThis is the amount of time from the start to the end of the\nimage sequence on which this effect is being invoked.  The total\nnumber of frames is total_time / time_step.\n\ntime_scale\nThese are the units that current_time, time_step, and total_time\nare in.  See QuickTime for an explanation of how these time values work.\n\nwidth\nheight\nThese are the size of the input image. As Stoney Ballard points out,\nthese are certainly NOT the same as the\twidth and height fields in param[0],\nbut rather reflect the full-resolution dimensions of the input layer.\n\nfield\nWill be set to PF_Field_UPPER or PF_Field_LOWER during field-rendering\nif certain conditions are met -- for example: effect must have\nPF_OutFlag_PIX_INDEPENDENT set, and the layer to which the effect is\napplied must not be rotated, scaled nor positioned on a subpixel.\nYou can safely ignore the setting of this field, but might be able to\noptimize things by only processing the specified field.\n\nextent_hint\nThis is a rectangle that indicates the intersection of the visible\nportions of the input and output layers.  For an effect that does\nnot do a geometric distortion of the image, copying just this rectangle\nfrom the source image to the destination image is sufficient to copy\nall the image data that the user will see.  This can speed up effects\nvery much.  Just iterate over only this rectangle of pixels.\n\noutput_origin_x\noutput_origin_y\nThese fields correspond to the origin returned in the out_data at\nPF_Cmd_FRAME_SETUP time. They indicate the position of the top left\ncorner of the input buffer in the output buffer.\n\ndownsample_x\ndownsample_y\nFor speed, the user may have asked for only every Nth vertical or\nhorizontal pixel to be actually rendered by After Effects.  The width\nand height of all effect parameters (including layers) will be\nautomatically adjusted to compensate, but the effect needs to know\nthe downsampling factors to correctly interpret scalar parameters\n(ie. sliders) that represent pixel distances in the image.\nDownsample factors will be in the range 1 to 999+.  This is set in\nSEQUENCE_SETUP or RESETUP as the case may be. As of PF_PLUG_IN_VERSION 2,\nthis factor is a rational quantity.\n\nglobal_data\nsequence_data\nframe_data\nThese fields are copied from the out data on previous invocations\nand set here for you to access as you need them.  They will only\nbe set if they have been allocated during previous commands.\n\npre_effect_source_origin_x\npre_effect_source_origin_y\nThese fields are the origin of the source image in the input buffer. They are set\nonly during frame calls (PF_Cmd_FRAME_SETUP, PF_Cmd_RENDER, PF_Cmd_FRAME_SETDOWN).\nThey will be non-zero only if one or more effects that preceded this effect\non the same layer resized the output buffer (i.e. specified that the output\nimage will be larger or smaller than the input image)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_OutData {
    pub my_version: A_u_long,
    pub name: [A_char; 32usize],
    pub global_data: PF_Handle,
    pub num_params: A_long,
    pub sequence_data: PF_Handle,
    pub flat_sdata_size: A_long,
    pub frame_data: PF_Handle,
    pub width: A_long,
    pub height: A_long,
    pub origin: PF_Point,
    pub out_flags: PF_OutFlags,
    pub return_msg: [A_char; 256usize],
    pub start_sampL: A_long,
    pub dur_sampL: A_long,
    pub dest_snd: PF_SoundWorld,
    pub out_flags2: PF_OutFlags2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_InData {
    pub inter: PF_InteractCallbacks,
    pub utils: *mut _PF_UtilCallbacks,
    pub effect_ref: PF_ProgPtr,
    pub quality: PF_Quality,
    pub version: PF_SpecVersion,
    pub serial_num: A_long,
    pub appl_id: A_long,
    pub num_params: A_long,
    pub reserved: A_long,
    pub what_cpu: A_long,
    pub what_fpu: A_long,
    pub current_time: A_long,
    pub time_step: A_long,
    pub total_time: A_long,
    pub local_time_step: A_long,
    pub time_scale: A_u_long,
    pub field: PF_Field,
    pub shutter_angle: PF_Fixed,
    pub width: A_long,
    pub height: A_long,
    pub extent_hint: PF_Rect,
    pub output_origin_x: A_long,
    pub output_origin_y: A_long,
    pub downsample_x: PF_RationalScale,
    pub downsample_y: PF_RationalScale,
    pub pixel_aspect_ratio: PF_RationalScale,
    pub in_flags: PF_InFlags,
    pub global_data: PF_Handle,
    pub sequence_data: PF_Handle,
    pub frame_data: PF_Handle,
    pub start_sampL: A_long,
    pub dur_sampL: A_long,
    pub total_sampL: A_long,
    pub src_snd: PF_SoundWorld,
    pub pica_basicP: *mut SPBasicSuite,
    pub pre_effect_source_origin_x: A_long,
    pub pre_effect_source_origin_y: A_long,
    pub shutter_phase: PF_Fixed,
}
#[doc = " -------------------- Effect Prototype --------------------\n\nThe effects module provides a single entry point corresponding to the\nbelow prototype through which all messages are dispatched to the\nappropriate code.\n\nThe cmd parameter is one of the PF_Cmd enumeration defined above.\nAll commands are discussed at that enumeration.  There are a lot.\n\nThe in_data and out_data parameters are respectively, PF_InData and\nPF_OutData blocks defined and described above.  The in_data contains\nread only information that the effect can use.  The out_data contains\nwrite only information through which the effect communicates back to\nthe calling program.  The descriptions above give a lot more detail.\n\nThe params list is an array of pointers to variably sized PF_ParamDef\nstructs.  This is in typical Unix-like argv format, where the last item\npoints to NULL.  The entries in this array describe the current settings\nof the parameters to the effect.  Params[0] is the layer to which the\neffect has been applied and is a PF_LayerDef param.  Other parameters\nare defined by the effect.\n\nThe output param is also a PF_LayerDef param, like params[0], and is\nan output buffer into which your effect should write the new contents\nof the layer.\n\nA brief explanation about parameter passing to effects:\n\nWhen you are invoked to Render, all \"params\" array entries will be filled\nwith their value at the current time, except for layer params other than\nthe default input layer parameter (ie. param[0]).  To get other layer param\nvalues, you must call the checkout_param callback.  (See callbacks above.)\n\nIn other words, on PF_Cmd_RENDER, params[0] will be a valid ready-to-use\nPF_EffectWorld and output will be a valid ready-to-use PF_EffectWorld.  Other params that\nare not layer params (i.e. sliders, popups, etc.) will be ready-to-use, filled\nwith their value at the current time; you do not need to call checkout_param for\nthem.  However, other params (besides [0]) that are layer params will NOT be\nfilled in correctly -- you must make a checkout_param callback to get them.\n\nANY param which you call checkout_param on, you must also call checkin_param\nbefore you exit.  If not, After Effects will automatically erase your effect\nmodule code resource from the users hard disk, along with any files that contain\nyour name or any nicknames you have.  Sorry.  Calling checkin_param is important!"]
pub type PF_FilterProc = ::std::option::Option<
    unsafe extern "C" fn(
        cmd: PF_Cmd,
        in_data: *mut PF_InData,
        out_data: *mut PF_OutData,
        params: PF_ParamList,
        output: *mut PF_LayerDef,
        extra: *mut ::std::os::raw::c_void,
    ) -> PF_Err,
>;
pub type PF_KernelFlags = A_u_long;
pub type PF_SampleEdgeBehav = A_u_long;
pub type PF_MaskFlags = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_MaskWorld {
    pub mask: PF_EffectWorld,
    pub offset: PF_Point,
    pub what_is_mask: PF_MaskFlags,
}
#[doc = " ---------- PF_SampPB ----------\n\nThere are calls to sample an a non-integral point in an image,\nand to sample an area of an image.  This parameter block describes\nsome information needed for these image resampling routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SampPB {
    pub x_radius: PF_Fixed,
    pub y_radius: PF_Fixed,
    pub area: PF_Fixed,
    pub src: *mut PF_EffectWorld,
    pub samp_behave: PF_SampleEdgeBehav,
    pub allow_asynch: A_long,
    pub motion_blur: A_long,
    pub comp_mode: PF_CompositeMode,
    pub mask0: PF_PixelPtr,
    pub fcm_table: *mut A_u_char,
    pub fcd_table: *mut A_u_char,
    pub reserved: [A_long; 8usize],
}
pub type PF_CallbackID = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_YouMustCastThisToActualFunctionType {
    _unused: [u8; 0],
}
#[doc = "Previous versions of PF_CallbackFunc were defined using varargs in attempt to enforce\nthe effect_ref passed as the first argument to all callbacks. The actual host\nimplementations are generally *not* varargs, and on some platforms the calling\nconventions between normal C ABI and C varargs ABI are not compatible. If your\ncode is trying to call through a PF_CallbackFunc it is unsafe; with this definition\nit will now no longer compile. To fix, cast to the proper API signature before\ncalling. Or better, use the extensive Suite implementations which are explicitly typed"]
pub type PF_CallbackFunc = *mut PF_YouMustCastThisToActualFunctionType;
pub type PF_PlatDataID = A_long;
pub type PF_Plane = A_u_long;
#[doc = " ---------- ANSI Routines Block ----------\n\nWithin the callback routines block there is a block of ANSI\nroutines, so that the filter will not need to link with the\nANSI library.  The following structure describes that block\nand is included in the larger Callback Routines block below.\n\nAll angles are expressed in radians; use PF_RAD_PER_DEGREE\nto convert from degrees to radians, if necessary.  Be aware\nthat angle parameter types use degrees (in fixed point).\n\nSprintf and strcpy are provided to facilitate string usage,\nsuch as printing for names and supervised controls.\n\nNone of these callbacks vary based on the Quality setting."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ANSICallbacks {
    pub atan: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub atan2: ::std::option::Option<unsafe extern "C" fn(y: A_FpLong, x: A_FpLong) -> A_FpLong>,
    pub ceil: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub cos: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub exp: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub fabs: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub floor: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub fmod: ::std::option::Option<unsafe extern "C" fn(x: A_FpLong, y: A_FpLong) -> A_FpLong>,
    pub hypot: ::std::option::Option<unsafe extern "C" fn(x: A_FpLong, y: A_FpLong) -> A_FpLong>,
    pub log: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub log10: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub pow: ::std::option::Option<unsafe extern "C" fn(x: A_FpLong, y: A_FpLong) -> A_FpLong>,
    pub sin: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub sqrt: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub tan: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub sprintf: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut A_char, arg2: *const A_char, ...) -> ::std::os::raw::c_int,
    >,
    pub strcpy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut A_char, arg2: *const A_char) -> *mut A_char,
    >,
    pub asin: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub acos: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub ansi_procs: [A_long; 1usize],
}
#[doc = " ---------- Colorspace Conversion Callbacks\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ColorCallbacks {
    pub RGBtoHLS: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            hls: *mut PF_Fixed,
        ) -> PF_Err,
    >,
    pub HLStoRGB: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            hls: *mut PF_Fixed,
            rgb: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub RGBtoYIQ: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            yiq: *mut PF_Fixed,
        ) -> PF_Err,
    >,
    pub YIQtoRGB: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            yiq: *mut PF_Fixed,
            rgb: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub Luminance: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            lum100: *mut A_long,
        ) -> PF_Err,
    >,
    pub Hue: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            hue: *mut A_long,
        ) -> PF_Err,
    >,
    pub Lightness: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            lightness: *mut A_long,
        ) -> PF_Err,
    >,
    pub Saturation: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            saturation: *mut A_long,
        ) -> PF_Err,
    >,
}
pub type PF_BatchSampleFunc = *mut ::std::os::raw::c_void;
pub type PF_BatchSample16Func = *mut ::std::os::raw::c_void;
pub type PF_NewWorldFlags = A_long;
#[doc = "prototypes for PF_ITERATE8 and PF_ITERATE16 pixel functions\n\nthe user of PF_ITERATE provides a refcon; After Effects may distribute iteration\nacross multiple threads, so any data pointed to by refconL should be read-only or\nproperly synchronized\n\ninP is writable only if the world you pass to PF_ITERATE() is PF_WorldFlag_WRITEABLE\n\n"]
pub type PF_IteratePixel8Func = ::std::option::Option<
    unsafe extern "C" fn(
        refconP: *mut ::std::os::raw::c_void,
        xL: A_long,
        yL: A_long,
        inP: *mut PF_Pixel,
        outP: *mut PF_Pixel,
    ) -> PF_Err,
>;
pub type PF_IteratePixel16Func = ::std::option::Option<
    unsafe extern "C" fn(
        refconP: *mut ::std::os::raw::c_void,
        xL: A_long,
        yL: A_long,
        inP: *mut PF_Pixel16,
        outP: *mut PF_Pixel16,
    ) -> PF_Err,
>;
pub type PF_IteratePixelFloatFunc = ::std::option::Option<
    unsafe extern "C" fn(
        refconP: *mut ::std::os::raw::c_void,
        xL: A_long,
        yL: A_long,
        inP: *mut PF_PixelFloat,
        outP: *mut PF_PixelFloat,
    ) -> PF_Err,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_UtilCallbacks {
    pub begin_sampling: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            qual: PF_Quality,
            mf: PF_ModeFlags,
            params: *mut PF_SampPB,
        ) -> PF_Err,
    >,
    pub subpixel_sample: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub area_sample: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub get_batch_func_is_deprecated: *mut ::std::os::raw::c_void,
    pub end_sampling: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            qual: PF_Quality,
            mf: PF_ModeFlags,
            params: *mut PF_SampPB,
        ) -> PF_Err,
    >,
    pub composite_rect: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src_rect: *mut PF_Rect,
            src_opacity: A_long,
            source_wld: *mut PF_EffectWorld,
            dest_x: A_long,
            dest_y: A_long,
            field_rdr: PF_Field,
            xfer_mode: PF_XferMode,
            dest_wld: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub blend: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src1: *const PF_EffectWorld,
            src2: *const PF_EffectWorld,
            ratio: PF_Fixed,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub convolve: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            flags: PF_KernelFlags,
            kernel_size: A_long,
            a_kernel: *mut ::std::os::raw::c_void,
            r_kernel: *mut ::std::os::raw::c_void,
            g_kernel: *mut ::std::os::raw::c_void,
            b_kernel: *mut ::std::os::raw::c_void,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            dst: *mut PF_EffectWorld,
            src_r: *mut PF_Rect,
            dst_r: *mut PF_Rect,
        ) -> PF_Err,
    >,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            color: *const PF_Pixel,
            dst_rect: *const PF_Rect,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub gaussian_kernel: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            kRadius: A_FpLong,
            flags: PF_KernelFlags,
            multiplier: A_FpLong,
            diameter: *mut A_long,
            kernel: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel8Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub premultiply: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            forward: A_long,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub premultiply_color: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            color: *const PF_Pixel,
            forward: A_long,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub new_world: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            width: A_long,
            height: A_long,
            flags: PF_NewWorldFlags,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub dispose_world: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, world: *mut PF_EffectWorld) -> PF_Err,
    >,
    pub iterate_origin: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel8Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_lut: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            a_lut0: *mut A_u_char,
            r_lut0: *mut A_u_char,
            g_lut0: *mut A_u_char,
            b_lut0: *mut A_u_char,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub transfer_rect: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            quality: PF_Quality,
            m_flags: PF_ModeFlags,
            field: PF_Field,
            src_rec: *const PF_Rect,
            src_world: *const PF_EffectWorld,
            comp_mode: *const PF_CompositeMode,
            mask_world0: *const PF_MaskWorld,
            dest_x: A_long,
            dest_y: A_long,
            dst_world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub transform_world: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            quality: PF_Quality,
            m_flags: PF_ModeFlags,
            field: PF_Field,
            src_world: *const PF_EffectWorld,
            comp_mode: *const PF_CompositeMode,
            mask_world0: *const PF_MaskWorld,
            matrices: *const PF_FloatMatrix,
            num_matrices: A_long,
            src2dst_matrix: PF_Boolean,
            dest_rect: *const PF_Rect,
            dst_world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub host_new_handle:
        ::std::option::Option<unsafe extern "C" fn(size: A_u_longlong) -> PF_Handle>,
    pub host_lock_handle: ::std::option::Option<
        unsafe extern "C" fn(pf_handle: PF_Handle) -> *mut ::std::os::raw::c_void,
    >,
    pub host_unlock_handle: ::std::option::Option<unsafe extern "C" fn(pf_handle: PF_Handle)>,
    pub host_dispose_handle: ::std::option::Option<unsafe extern "C" fn(pf_handle: PF_Handle)>,
    pub get_callback_addr: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            quality: PF_Quality,
            mode_flags: PF_ModeFlags,
            which_callback: PF_CallbackID,
            fn_ptr: *mut PF_CallbackFunc,
        ) -> PF_Err,
    >,
    pub app:
        ::std::option::Option<unsafe extern "C" fn(arg1: PF_ProgPtr, arg2: A_long, ...) -> PF_Err>,
    pub ansi: PF_ANSICallbacks,
    pub colorCB: PF_ColorCallbacks,
    pub get_platform_data: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            which: PF_PlatDataID,
            data: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub host_get_handle_size:
        ::std::option::Option<unsafe extern "C" fn(pf_handle: PF_Handle) -> A_u_longlong>,
    pub iterate_origin_non_clip_src: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel8Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_generic: ::std::option::Option<
        unsafe extern "C" fn(
            iterationsL: A_long,
            refconPV: *mut ::std::os::raw::c_void,
            fn_func: ::std::option::Option<
                unsafe extern "C" fn(
                    refconPV: *mut ::std::os::raw::c_void,
                    thread_indexL: A_long,
                    i: A_long,
                    iterationsL: A_long,
                ) -> PF_Err,
            >,
        ) -> PF_Err,
    >,
    pub host_resize_handle: ::std::option::Option<
        unsafe extern "C" fn(new_sizeL: A_u_longlong, handlePH: *mut PF_Handle) -> PF_Err,
    >,
    pub subpixel_sample16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel16,
        ) -> PF_Err,
    >,
    pub area_sample16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel16,
        ) -> PF_Err,
    >,
    pub fill16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            color: *const PF_Pixel16,
            dst_rect: *const PF_Rect,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub premultiply_color16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            color: *const PF_Pixel16,
            forward: A_long,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate16: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel16Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_origin16: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel16Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_origin_non_clip_src16: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel16Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub get_pixel_data8: ::std::option::Option<
        unsafe extern "C" fn(
            worldP: *mut PF_EffectWorld,
            pixelsP0: PF_PixelPtr,
            pixPP: *mut *mut PF_Pixel8,
        ) -> PF_Err,
    >,
    pub get_pixel_data16: ::std::option::Option<
        unsafe extern "C" fn(
            worldP: *mut PF_EffectWorld,
            pixelsP0: PF_PixelPtr,
            pixPP: *mut *mut PF_Pixel16,
        ) -> PF_Err,
    >,
    pub reserved: [A_long; 1usize],
}
pub type PF_UtilCallbacks = _PF_UtilCallbacks;
pub type PF_TimeDisplay = csSDK_uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PixelFormatSuite1 {
    pub AddSupportedPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, pixelFormat: PrPixelFormat) -> PF_Err,
    >,
    pub ClearSupportedPixelFormats:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub NewWorldOfPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            width: A_u_long,
            height: A_u_long,
            flags: PF_NewWorldFlags,
            pixelFormat: PrPixelFormat,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub DisposeWorld: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, world: *mut PF_EffectWorld) -> PF_Err,
    >,
    pub GetPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inWorld: *mut PF_EffectWorld,
            pixelFormat: *mut PrPixelFormat,
        ) -> PF_Err,
    >,
    pub GetBlackForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub GetWhiteForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub ConvertColorToPixelFormattedData: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            alpha: f32,
            red: f32,
            green: f32,
            blue: f32,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_BackgroundFrameSuite1 {
    pub AddSupportedBackgroundTransferMode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            supportedTransferMode: PF_TransferMode,
            supportedPixelFormat: PrPixelFormat,
        ) -> PF_Err,
    >,
    pub GetBackgroundFrame: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            backgroundFrame: *mut *mut PF_LayerDef,
            backgroundTransferMode: *mut PF_TransferMode,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite4 {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub EffectDependsOnClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inDependsOnClipName: A_Boolean) -> PF_Err,
    >,
    pub SetEffectInstanceName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inSDKString: *const PrSDKString) -> PF_Err,
    >,
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub GetOriginalClipFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectDependsOnClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inDependsOnClipName: A_Boolean,
            inLayerParamIndex: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub GetMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inApplyTrim: bool,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetCommentString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLogNoteString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetCameraRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetClientMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDailyRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDescriptionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLabRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSceneString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetShotString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetTapeNameString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetVideoCodecString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetGoodMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSoundRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSequenceTime: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSoundTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetOriginalClipFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetMediaFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaActualStartTime: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipActualStartTime: *mut PrTime,
        ) -> PF_Err,
    >,
    pub IsSourceTrackMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackEmpty: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outIsTrackEmpty: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackItemEffectAppliedToSynthetic: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            outIsTrackItemEffectAppliedToSynthetic: *mut bool,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite10 {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub EffectDependsOnClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inDependsOnClipName: A_Boolean) -> PF_Err,
    >,
    pub SetEffectInstanceName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inSDKString: *const PrSDKString) -> PF_Err,
    >,
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub GetOriginalClipFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectDependsOnClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inDependsOnClipName: A_Boolean,
            inLayerParamIndex: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub GetMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inApplyTrim: bool,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetCommentString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLogNoteString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetCameraRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetClientMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDailyRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDescriptionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLabRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSceneString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetShotString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetTapeNameString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetVideoCodecString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetGoodMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSoundRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSequenceTime: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSoundTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetOriginalClipFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetMediaFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaActualStartTime: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipActualStartTime: *mut PrTime,
        ) -> PF_Err,
    >,
    pub IsSourceTrackMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackEmpty: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outIsTrackEmpty: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackItemEffectAppliedToSynthetic: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            outIsTrackItemEffectAppliedToSynthetic: *mut bool,
        ) -> PF_Err,
    >,
    pub GetSourceTrackCurrentMediaTimeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inUseSoundTimecodeAsStartTime: bool,
            inSequenceTime: PrTime,
            outCurrentMediaTime: *mut PrTime,
            outMediaTicksPerFrame: *mut PrTime,
            outMediaTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSequenceZeroPoint: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outZeroPointTime: *mut PrTime) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite11 {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub EffectDependsOnClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inDependsOnClipName: A_Boolean) -> PF_Err,
    >,
    pub SetEffectInstanceName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inSDKString: *const PrSDKString) -> PF_Err,
    >,
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub GetOriginalClipFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectDependsOnClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inDependsOnClipName: A_Boolean,
            inLayerParamIndex: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub GetMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inApplyTrim: bool,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetCommentString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLogNoteString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetCameraRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetClientMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDailyRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDescriptionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLabRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSceneString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetShotString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetTapeNameString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetVideoCodecString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetGoodMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSoundRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSequenceTime: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSoundTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetOriginalClipFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetMediaFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaActualStartTime: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipActualStartTime: *mut PrTime,
        ) -> PF_Err,
    >,
    pub IsSourceTrackMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackEmpty: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outIsTrackEmpty: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackItemEffectAppliedToSynthetic: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            outIsTrackItemEffectAppliedToSynthetic: *mut bool,
        ) -> PF_Err,
    >,
    pub GetSourceTrackCurrentMediaTimeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inUseSoundTimecodeAsStartTime: bool,
            inSequenceTime: PrTime,
            outCurrentMediaTime: *mut PrTime,
            outMediaTicksPerFrame: *mut PrTime,
            outMediaTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSequenceZeroPoint: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outZeroPointTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackCurrentClipDuration: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipDuration: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSequenceDuration: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceDuration: *mut PrTime) -> PF_Err,
    >,
    pub GetVideoResolutionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
}
pub type PF_UtilitySuiteVersion1 = PF_UtilitySuite;
pub type PF_UtilitySuite2 = PF_UtilitySuite;
pub type PF_UtilitySuite3 = PF_UtilitySuite;
pub type PF_UtilitySuite5 = PF_UtilitySuite;
pub type PF_UtilitySuite6 = PF_UtilitySuite;
pub type PF_UtilitySuite7 = PF_UtilitySuite;
pub type PF_UtilitySuite8 = PF_UtilitySuite;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SourceSettingsSuite {
    pub PerformSourceSettingsCommand: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            ioCommandStruct: *mut ::std::os::raw::c_void,
            inDataSize: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub SetIsSourceSettingsEffect: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inIsSourceSettingsEffect: A_Boolean,
        ) -> PF_Err,
    >,
}
pub type PF_SourceSettingsSuite2 = PF_SourceSettingsSuite;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_TransitionSuite {
    #[doc = "\tRegister an effect as a transition using the passed in\n\tinput layer as the outgoing clip. When registered the effect\n\twill be available to be dragged directly onto clip ends rather\n\tthan only applied to layers."]
    pub RegisterTransitionInputParam: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, inIndex: PF_ParamIndex) -> PF_Err,
    >,
    #[doc = "\tRegister a PF_ADD_FLOAT_SLIDER parameter to receive\n\tchanges to the start of the transition region through the\n\tPF_Cmd_USER_CHANGED_PARAM command."]
    pub RegisterTransitionStartParam: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, inIndex: PF_ParamIndex) -> PF_Err,
    >,
    #[doc = "\tRegister a PF_ADD_FLOAT_SLIDER parameter to receive\n\tchanges to the end of the transition region through the\n\tPF_Cmd_USER_CHANGED_PARAM command."]
    pub RegisterTransitionEndParam: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, inIndex: PF_ParamIndex) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueEffectDataType {
    _unused: [u8; 0],
}
#[doc = "\tThis suite provides effects a means to share unflattened sequence data between its instances.\n  The data is opaque to the host and effects are responsible for maintaining thread safety\n  of the shared data.  The host provides ref counting that the effect can use to manage\n  the lifetime of the shared data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKOpaqueEffectDataSuite {
    #[doc = "\tAcquire pointer to opaque effect data.  This is reference counted meaning that\n  AcquireOpaqueEffectData and ReleaseOpaqueEffectData should always be called in pairs.\n  If no opaque effect was registered for the given effect_ref AcquireOpaqueEffectData\n  will return 0 and the reference count remains 0."]
    pub AcquireOpaqueEffectData: ::std::option::Option<
        unsafe extern "C" fn(
            instanceID: csSDK_int32,
            outOpaqueEffectDataPP: *mut *mut OpaqueEffectDataType,
        ) -> PF_Err,
    >,
    #[doc = "\tRegister opaque effect data.  If multiple threads invoke RegisterOpaqueEffectData\n  only one will be successful.  The ioOpaqueEffectDataPP of the successful thread\n  will be returned to all callers.  Calling threads are always responsible for\n  managing the data they register.  This is the case whether or not threads are\n  successful registering their data.\n  Similarly, RegisterOpaqueEffectData always increments the internal reference count.\n\n//\n// Sample code showing how to use RegisterOpaqueEffectData.\n// Note: code is simplified (not exception-safe, etc.)\n//\n\n//\n// Try to acquire first, in case another thread registered the opaque effect data earlier\n//\nOpaqueEffectDataType * pData = 0;\nPF_Err err = opaqueEffectDataSuite->AcquireOpaqueEffectData(instanceID, &pData);\nassert(err == PF_Err_NONE);\n\n//\n// If acquire did not return a valid pointer, create a new object and register it\n// otherwise we are done\n//\nif (pData == 0)\n{\nOpaqueEffectDataType * pNewData(new OpaqueEffectDataType());\npData = pNewData;\nerr = opaqueEffectDataSuite->RegisterOpaqueEffectData(instanceID, &pData);\nassert(err == PF_Err_NONE);\n\n// now we check if this thread actually succeeded registering\n// if the returned pData is unchanged it means that it was successful\nif (pData != pNewData)\n{\ndelete pNewData;\n}\n}\n\n// pData now points to the right OpaqueEffectDataType object and we can start using it\n...\n\n\n\n"]
    pub RegisterOpaqueEffectData: ::std::option::Option<
        unsafe extern "C" fn(
            instanceID: csSDK_int32,
            ioOpaqueEffectDataPP: *mut *mut OpaqueEffectDataType,
        ) -> PF_Err,
    >,
    #[doc = "\tRelease opaque effect data.  This decrements the internal reference count.\n  If the internal reference count goes to 0 outDisposeOpaqueEffectDataPP is set\n  to the managed data that should be deleted, otherwise it is set to NULL.\n  If the internal reference count goes to 0 any calls made to AcquireOpaqueEffectData\n  will return 0 until new opaque effect data is registered via RegisterOpaqueEffectData."]
    pub ReleaseOpaqueEffectData: ::std::option::Option<
        unsafe extern "C" fn(
            instanceID: csSDK_int32,
            outDisposeOpaqueEffectDataPP: *mut *mut OpaqueEffectDataType,
        ) -> PF_Err,
    >,
}
pub const PrPixelFormatGpu_GPU_BGRA_4444_32f: PrPixelFormatGpu = 1094992704;
pub const PrPixelFormatGpu_GPU_BGRA_4444_16f: PrPixelFormatGpu = 1631863616;
pub type PrPixelFormatGpu = ::std::os::raw::c_int;
